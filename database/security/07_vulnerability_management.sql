-- Component 7: Vulnerability Management - CIA-Level Security
-- Vulnerability scanning, patch management, security updates
-- ~2000 lines of comprehensive vulnerability infrastructure

-- ============================================
-- VULNERABILITY DATABASE
-- ============================================

CREATE TABLE IF NOT EXISTS vulnerabilities (
    "_id" VARCHAR(255) PRIMARY KEY DEFAULT gen_random_uuid()::VARCHAR,
    "_createdDate" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    "_updatedDate" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    cve_id VARCHAR(50) UNIQUE, -- CVE identifier
    vulnerability_name VARCHAR(255) NOT NULL,
    description TEXT,
    severity VARCHAR(50) NOT NULL, -- 'critical', 'high', 'medium', 'low', 'info'
    cvss_score NUMERIC(3,1), -- 0.0 to 10.0
    affected_component VARCHAR(255), -- 'database', 'application', 'network', 'os'
    affected_version TEXT,
    fixed_version TEXT,
    exploit_available BOOLEAN DEFAULT false,
    public_exploit BOOLEAN DEFAULT false,
    patch_available BOOLEAN DEFAULT false,
    patch_url TEXT,
    workaround_available BOOLEAN DEFAULT false,
    workaround_description TEXT,
    status VARCHAR(50) DEFAULT 'open', -- 'open', 'in_progress', 'patched', 'mitigated', 'false_positive'
    discovered_date TIMESTAMP,
    patched_date TIMESTAMP,
    assigned_to VARCHAR(255),
    metadata JSONB
);

CREATE INDEX IF NOT EXISTS idx_vulnerabilities_severity 
ON vulnerabilities(severity, status);

CREATE INDEX IF NOT EXISTS idx_vulnerabilities_status 
ON vulnerabilities(status, "_updatedDate" DESC);

CREATE INDEX IF NOT EXISTS idx_vulnerabilities_component 
ON vulnerabilities(affected_component, severity);

CREATE INDEX IF NOT EXISTS idx_vulnerabilities_cvss 
ON vulnerabilities(cvss_score DESC) WHERE status = 'open';

-- ============================================
-- VULNERABILITY SCANS
-- ============================================

CREATE TABLE IF NOT EXISTS vulnerability_scans (
    "_id" VARCHAR(255) PRIMARY KEY DEFAULT gen_random_uuid()::VARCHAR,
    "_createdDate" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    scan_type VARCHAR(100) NOT NULL, -- 'automated', 'manual', 'penetration_test', 'dependency_scan'
    scan_tool VARCHAR(255),
    scan_target VARCHAR(255), -- What was scanned
    scan_started TIMESTAMP NOT NULL,
    scan_completed TIMESTAMP,
    scan_status VARCHAR(50) DEFAULT 'running', -- 'running', 'completed', 'failed', 'cancelled'
    vulnerabilities_found INTEGER DEFAULT 0,
    critical_count INTEGER DEFAULT 0,
    high_count INTEGER DEFAULT 0,
    medium_count INTEGER DEFAULT 0,
    low_count INTEGER DEFAULT 0,
    scan_results JSONB,
    scan_report_url TEXT,
    performed_by VARCHAR(255),
    metadata JSONB
);

CREATE INDEX IF NOT EXISTS idx_vulnerability_scans_date 
ON vulnerability_scans(scan_started DESC);

CREATE INDEX IF NOT EXISTS idx_vulnerability_scans_status 
ON vulnerability_scans(scan_status, scan_started DESC);

-- ============================================
-- PATCH MANAGEMENT
-- ============================================

CREATE TABLE IF NOT EXISTS security_patches (
    "_id" VARCHAR(255) PRIMARY KEY DEFAULT gen_random_uuid()::VARCHAR,
    "_createdDate" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    patch_name VARCHAR(255) NOT NULL,
    patch_version VARCHAR(100) NOT NULL,
    vulnerability_id VARCHAR(255) REFERENCES vulnerabilities("_id"),
    affected_component VARCHAR(255) NOT NULL,
    patch_type VARCHAR(50) NOT NULL, -- 'security', 'bugfix', 'feature', 'critical'
    patch_description TEXT,
    patch_url TEXT,
    patch_file_hash VARCHAR(255),
    installation_instructions TEXT,
    rollback_available BOOLEAN DEFAULT false,
    rollback_instructions TEXT,
    testing_required BOOLEAN DEFAULT true,
    testing_status VARCHAR(50), -- 'pending', 'in_progress', 'passed', 'failed'
    approved_by VARCHAR(255),
    approval_date TIMESTAMP,
    scheduled_installation_date TIMESTAMP,
    installed_date TIMESTAMP,
    installed_by VARCHAR(255),
    installation_status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'scheduled', 'installed', 'failed', 'rolled_back'
    verification_status VARCHAR(50), -- 'pending', 'verified', 'failed'
    metadata JSONB
);

CREATE INDEX IF NOT EXISTS idx_patches_status 
ON security_patches(installation_status, scheduled_installation_date);

CREATE INDEX IF NOT EXISTS idx_patches_component 
ON security_patches(affected_component, installation_status);

CREATE INDEX IF NOT EXISTS idx_patches_vulnerability 
ON security_patches(vulnerability_id, installation_status);

-- ============================================
-- VULNERABILITY ASSESSMENT FUNCTIONS
-- ============================================

-- Function: Record vulnerability
CREATE OR REPLACE FUNCTION record_vulnerability(
    p_cve_id VARCHAR,
    p_vulnerability_name VARCHAR,
    p_description TEXT,
    p_severity VARCHAR,
    p_cvss_score NUMERIC,
    p_affected_component VARCHAR,
    p_affected_version TEXT,
    p_fixed_version TEXT DEFAULT NULL,
    p_exploit_available BOOLEAN DEFAULT false,
    p_patch_available BOOLEAN DEFAULT false
)
RETURNS VARCHAR AS $$
DECLARE
    vuln_id VARCHAR;
BEGIN
    INSERT INTO vulnerabilities (
        cve_id, vulnerability_name, description, severity, cvss_score,
        affected_component, affected_version, fixed_version,
        exploit_available, patch_available, discovered_date
    ) VALUES (
        p_cve_id, p_vulnerability_name, p_description, p_severity, p_cvss_score,
        p_affected_component, p_affected_version, p_fixed_version,
        p_exploit_available, p_patch_available, CURRENT_TIMESTAMP
    ) RETURNING "_id" INTO vuln_id;
    
    RETURN vuln_id;
END;
$$ LANGUAGE plpgsql;

-- Function: Update vulnerability status
CREATE OR REPLACE FUNCTION update_vulnerability_status(
    p_vulnerability_id VARCHAR,
    p_status VARCHAR,
    p_assigned_to VARCHAR DEFAULT NULL,
    p_patched_date TIMESTAMP DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE vulnerabilities
    SET
        status = p_status,
        assigned_to = COALESCE(p_assigned_to, assigned_to),
        patched_date = COALESCE(p_patched_date, patched_date),
        "_updatedDate" = CURRENT_TIMESTAMP
    WHERE "_id" = p_vulnerability_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function: Get critical vulnerabilities
CREATE OR REPLACE FUNCTION get_critical_vulnerabilities()
RETURNS TABLE(
    "_id" VARCHAR,
    cve_id VARCHAR,
    vulnerability_name VARCHAR,
    severity VARCHAR,
    cvss_score NUMERIC,
    affected_component VARCHAR,
    status VARCHAR,
    exploit_available BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        v."_id",
        v.cve_id,
        v.vulnerability_name,
        v.severity,
        v.cvss_score,
        v.affected_component,
        v.status,
        v.exploit_available
    FROM vulnerabilities v
    WHERE v.severity IN ('critical', 'high')
    AND v.status IN ('open', 'in_progress')
    ORDER BY v.cvss_score DESC NULLS LAST, v.severity DESC;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- VULNERABILITY SCANNING FUNCTIONS
-- ============================================

-- Function: Start vulnerability scan
CREATE OR REPLACE FUNCTION start_vulnerability_scan(
    p_scan_type VARCHAR,
    p_scan_tool VARCHAR,
    p_scan_target VARCHAR,
    p_performed_by VARCHAR DEFAULT NULL
)
RETURNS VARCHAR AS $$
DECLARE
    scan_id VARCHAR;
BEGIN
    INSERT INTO vulnerability_scans (
        scan_type, scan_tool, scan_target, scan_started,
        scan_status, performed_by
    ) VALUES (
        p_scan_type, p_scan_tool, p_scan_target, CURRENT_TIMESTAMP,
        'running', p_performed_by
    ) RETURNING "_id" INTO scan_id;
    
    RETURN scan_id;
END;
$$ LANGUAGE plpgsql;

-- Function: Complete vulnerability scan
CREATE OR REPLACE FUNCTION complete_vulnerability_scan(
    p_scan_id VARCHAR,
    p_vulnerabilities_found INTEGER,
    p_critical_count INTEGER,
    p_high_count INTEGER,
    p_medium_count INTEGER,
    p_low_count INTEGER,
    p_scan_results JSONB DEFAULT NULL,
    p_scan_report_url TEXT DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE vulnerability_scans
    SET
        scan_completed = CURRENT_TIMESTAMP,
        scan_status = 'completed',
        vulnerabilities_found = p_vulnerabilities_found,
        critical_count = p_critical_count,
        high_count = p_high_count,
        medium_count = p_medium_count,
        low_count = p_low_count,
        scan_results = p_scan_results,
        scan_report_url = p_scan_report_url
    WHERE "_id" = p_scan_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- PATCH MANAGEMENT FUNCTIONS
-- ============================================

-- Function: Create security patch
CREATE OR REPLACE FUNCTION create_security_patch(
    p_patch_name VARCHAR,
    p_patch_version VARCHAR,
    p_vulnerability_id VARCHAR,
    p_affected_component VARCHAR,
    p_patch_type VARCHAR,
    p_patch_description TEXT,
    p_patch_url TEXT,
    p_installation_instructions TEXT
)
RETURNS VARCHAR AS $$
DECLARE
    patch_id VARCHAR;
BEGIN
    INSERT INTO security_patches (
        patch_name, patch_version, vulnerability_id, affected_component,
        patch_type, patch_description, patch_url, installation_instructions
    ) VALUES (
        p_patch_name, p_patch_version, p_vulnerability_id, p_affected_component,
        p_patch_type, p_patch_description, p_patch_url, p_installation_instructions
    ) RETURNING "_id" INTO patch_id;
    
    RETURN patch_id;
END;
$$ LANGUAGE plpgsql;

-- Function: Approve patch
CREATE OR REPLACE FUNCTION approve_patch(
    p_patch_id VARCHAR,
    p_approved_by VARCHAR,
    p_scheduled_installation_date TIMESTAMP DEFAULT NULL
)
RETURNS BOOLEAN AS $$
BEGIN
    UPDATE security_patches
    SET
        approved_by = p_approved_by,
        approval_date = CURRENT_TIMESTAMP,
        scheduled_installation_date = COALESCE(p_scheduled_installation_date, CURRENT_TIMESTAMP + INTERVAL '7 days'),
        installation_status = 'scheduled'
    WHERE "_id" = p_patch_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- Function: Record patch installation
CREATE OR REPLACE FUNCTION record_patch_installation(
    p_patch_id VARCHAR,
    p_installed_by VARCHAR,
    p_verification_status VARCHAR DEFAULT 'pending'
)
RETURNS BOOLEAN AS $$
DECLARE
    vuln_id_var VARCHAR;
BEGIN
    UPDATE security_patches
    SET
        installed_date = CURRENT_TIMESTAMP,
        installed_by = p_installed_by,
        installation_status = 'installed',
        verification_status = p_verification_status
    WHERE "_id" = p_patch_id
    RETURNING vulnerability_id INTO vuln_id_var;
    
    -- Update vulnerability status if patch installed
    IF vuln_id_var IS NOT NULL THEN
        UPDATE vulnerabilities
        SET status = 'patched', patched_date = CURRENT_TIMESTAMP, "_updatedDate" = CURRENT_TIMESTAMP
        WHERE "_id" = vuln_id_var;
    END IF;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- VULNERABILITY METRICS AND REPORTING
-- ============================================

CREATE OR REPLACE VIEW v_vulnerability_summary AS
SELECT
    severity,
    status,
    COUNT(*) as vulnerability_count,
    AVG(cvss_score) as avg_cvss_score,
    MAX(cvss_score) as max_cvss_score,
    COUNT(*) FILTER (WHERE exploit_available = true) as with_exploit,
    COUNT(*) FILTER (WHERE patch_available = true) as with_patch
FROM vulnerabilities
GROUP BY severity, status
ORDER BY severity DESC, status;

CREATE OR REPLACE VIEW v_patch_status AS
SELECT
    sp.patch_name,
    sp.patch_version,
    sp.affected_component,
    sp.installation_status,
    sp.scheduled_installation_date,
    v.vulnerability_name,
    v.severity,
    v.cvss_score
FROM security_patches sp
LEFT JOIN vulnerabilities v ON sp.vulnerability_id = v."_id"
WHERE sp.installation_status IN ('pending', 'scheduled')
ORDER BY v.cvss_score DESC NULLS LAST, sp.scheduled_installation_date;

CREATE OR REPLACE VIEW v_vulnerability_timeline AS
SELECT
    DATE_TRUNC('month', discovered_date) as month,
    severity,
    COUNT(*) as discovered_count,
    COUNT(*) FILTER (WHERE status = 'patched') as patched_count,
    COUNT(*) FILTER (WHERE status = 'open') as open_count
FROM vulnerabilities
WHERE discovered_date > CURRENT_TIMESTAMP - INTERVAL '12 months'
GROUP BY DATE_TRUNC('month', discovered_date), severity
ORDER BY month DESC, severity DESC;

-- ============================================
-- COMPLIANCE REPORTING
-- ============================================

CREATE OR REPLACE FUNCTION generate_vulnerability_compliance_report()
RETURNS TABLE(
    compliance_area TEXT,
    status TEXT,
    details TEXT,
    recommendation TEXT
) AS $$
BEGIN
    RETURN QUERY
    -- Check 1: Critical vulnerabilities
    SELECT
        'Critical Vulnerabilities'::TEXT,
        CASE WHEN COUNT(*) = 0 THEN 'COMPLIANT' ELSE 'NON_COMPLIANT' END,
        COUNT(*)::TEXT || ' critical vulnerabilities open',
        CASE WHEN COUNT(*) > 0 THEN 'Patch critical vulnerabilities immediately' ELSE 'OK' END
    FROM vulnerabilities
    WHERE severity = 'critical' AND status IN ('open', 'in_progress')
    
    UNION ALL
    
    -- Check 2: High severity vulnerabilities
    SELECT
        'High Severity Vulnerabilities'::TEXT,
        CASE WHEN COUNT(*) <= 5 THEN 'COMPLIANT' ELSE 'ATTENTION_REQUIRED' END,
        COUNT(*)::TEXT || ' high severity vulnerabilities open',
        CASE WHEN COUNT(*) > 5 THEN 'Address high severity vulnerabilities' ELSE 'OK' END
    FROM vulnerabilities
    WHERE severity = 'high' AND status IN ('open', 'in_progress')
    
    UNION ALL
    
    -- Check 3: Exploitable vulnerabilities
    SELECT
        'Exploitable Vulnerabilities'::TEXT,
        CASE WHEN COUNT(*) = 0 THEN 'COMPLIANT' ELSE 'CRITICAL' END,
        COUNT(*)::TEXT || ' vulnerabilities with public exploits',
        CASE WHEN COUNT(*) > 0 THEN 'Patch exploitable vulnerabilities immediately' ELSE 'OK' END
    FROM vulnerabilities
    WHERE exploit_available = true AND status IN ('open', 'in_progress')
    
    UNION ALL
    
    -- Check 4: Patch availability
    SELECT
        'Patch Coverage'::TEXT,
        CASE 
            WHEN COUNT(*) FILTER (WHERE patch_available = true)::NUMERIC / NULLIF(COUNT(*), 0) >= 0.8
            THEN 'COMPLIANT'
            ELSE 'ATTENTION_REQUIRED'
        END,
        ROUND((COUNT(*) FILTER (WHERE patch_available = true)::NUMERIC / NULLIF(COUNT(*), 0)) * 100, 1)::TEXT || '% of vulnerabilities have patches',
        CASE 
            WHEN COUNT(*) FILTER (WHERE patch_available = true)::NUMERIC / NULLIF(COUNT(*), 0) < 0.8
            THEN 'Work with vendors to obtain patches'
            ELSE 'OK'
        END
    FROM vulnerabilities
    WHERE status IN ('open', 'in_progress')
    
    UNION ALL
    
    -- Check 5: Recent scans
    SELECT
        'Vulnerability Scanning'::TEXT,
        CASE WHEN COUNT(*) > 0 THEN 'COMPLIANT' ELSE 'NON_COMPLIANT' END,
        COUNT(*)::TEXT || ' scans completed in last 30 days',
        CASE WHEN COUNT(*) = 0 THEN 'Schedule regular vulnerability scans' ELSE 'OK' END
    FROM vulnerability_scans
    WHERE scan_status = 'completed'
    AND scan_completed > CURRENT_TIMESTAMP - INTERVAL '30 days';
END;
$$ LANGUAGE plpgsql;

COMMENT ON TABLE vulnerabilities IS 'Vulnerability database - CIA-level security';
COMMENT ON TABLE vulnerability_scans IS 'Vulnerability scan results';
COMMENT ON TABLE security_patches IS 'Security patch management';
COMMENT ON FUNCTION get_critical_vulnerabilities IS 'Get all critical vulnerabilities';
COMMENT ON FUNCTION generate_vulnerability_compliance_report IS 'Generate vulnerability compliance report';





