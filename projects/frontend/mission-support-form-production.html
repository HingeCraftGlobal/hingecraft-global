<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mission Support - HingeCraft Global</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .prose h1 { font-size: 1.5rem; font-weight: 700; margin-top: 1.25rem; }
    .prose h2 { font-size: 1.25rem; font-weight: 600; margin-top: 1rem; }
    .prose h3 { font-size: 1.125rem; font-weight: 600; margin-top: 1rem; }
    .prose p { margin-top: 0.75rem; line-height: 1.6; }
    .prose ul, .prose ol { margin-left: 1.25rem; margin-top: 0.5rem; }
    .prose li { margin-top: 0.25rem; }
  </style>
</head>
<body class="bg-slate-100">
  <div id="root" class="min-h-screen py-6"></div>
  
  <!-- Wix Velo API for storage integration -->
  <script src="https://static.parastorage.com/services/js-sdk/1.231.0/js/wix-private.js"></script>
  
  <script type="text/babel" data-presets="env,react">
    const { useEffect, useState } = React;

    // Validation patterns
    const VALIDATION_PATTERNS = {
      firstName: /^[a-zA-Z\-\s]{1,50}$/,
      lastName: /^[a-zA-Z\-\s]{1,50}$/,
      email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
      address: /^[a-zA-Z0-9\s\-\.,#]{1,200}$/,
      missionSupportName: /^[a-zA-Z0-9\s\-\.,]{0,200}$/,
      amount: /^\d{1,5}(\.\d{1,2})?$/
    };

    const AMOUNT_CONFIG = {
      MIN: 1.00,
      MAX: 25000.00,
      PRESETS: [1, 5, 10]
    };

    function MissionSupportForm() {
      const [formData, setFormData] = useState({
        firstName: '',
        lastName: '',
        email: '',
        address: '',
        missionSupportName: '',
        amount: null,
        otherAmount: ''
      });
      
      const [errors, setErrors] = useState({});
      const [selectedPreset, setSelectedPreset] = useState(null);
      const [showOtherInput, setShowOtherInput] = useState(false);
      const [isSubmitting, setIsSubmitting] = useState(false);
      const [sessionRestored, setSessionRestored] = useState(false);
      const [paymentMethod, setPaymentMethod] = useState('card'); // 'card' or 'crypto'
      const [cryptoInvoice, setCryptoInvoice] = useState(null); // NOWPayments invoice data

      // Restore form data from session on mount
      useEffect(() => {
        restoreFormFromSession();
      }, []);

      function restoreFormFromSession() {
        try {
          // Try Wix Storage first
          if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            const stored = wixStorage.session.getItem('missionSupportFormData');
            if (stored) {
              const data = JSON.parse(stored);
              setFormData(data);
              if (data.amount) {
                if (AMOUNT_CONFIG.PRESETS.includes(data.amount)) {
                  setSelectedPreset(data.amount);
                } else {
                  setShowOtherInput(true);
                  setFormData(prev => ({ ...prev, otherAmount: String(data.amount) }));
                }
              }
              setSessionRestored(true);
              return;
            }
          }

          // Fallback to sessionStorage
          if (typeof sessionStorage !== 'undefined') {
            const stored = sessionStorage.getItem('missionSupportFormData');
            if (stored) {
              const data = JSON.parse(stored);
              setFormData(data);
              if (data.amount) {
                if (AMOUNT_CONFIG.PRESETS.includes(data.amount)) {
                  setSelectedPreset(data.amount);
                } else {
                  setShowOtherInput(true);
                  setFormData(prev => ({ ...prev, otherAmount: String(data.amount) }));
                }
              }
              setSessionRestored(true);
            }
          }
        } catch (e) {
          console.error('Error restoring form from session:', e);
        }
      }

      function saveFormToSession(data) {
        try {
          const sessionData = {
            ...data,
            timestamp: new Date().toISOString()
          };

          // Save to Wix Storage
          if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('missionSupportFormData', JSON.stringify(sessionData));
          }

          // Fallback to sessionStorage
          if (typeof sessionStorage !== 'undefined') {
            sessionStorage.setItem('missionSupportFormData', JSON.stringify(sessionData));
          }
        } catch (e) {
          console.error('Error saving form to session:', e);
        }
      }

      function validateField(name, value) {
        const fieldErrors = { ...errors };

        switch (name) {
          case 'firstName':
            if (!value.trim()) {
              fieldErrors.firstName = 'First name is required';
            } else if (!VALIDATION_PATTERNS.firstName.test(value)) {
              fieldErrors.firstName = 'First name must be 1-50 characters (letters, hyphens, spaces only)';
            } else {
              delete fieldErrors.firstName;
            }
            break;

          case 'lastName':
            if (!value.trim()) {
              fieldErrors.lastName = 'Last name is required';
            } else if (!VALIDATION_PATTERNS.lastName.test(value)) {
              fieldErrors.lastName = 'Last name must be 1-50 characters (letters, hyphens, spaces only)';
            } else {
              delete fieldErrors.lastName;
            }
            break;

          case 'email':
            if (!value.trim()) {
              fieldErrors.email = 'Email is required';
            } else if (!VALIDATION_PATTERNS.email.test(value)) {
              fieldErrors.email = 'Please enter a valid email address';
            } else {
              delete fieldErrors.email;
            }
            break;

          case 'address':
            if (!value.trim()) {
              fieldErrors.address = 'Address is required';
            } else if (!VALIDATION_PATTERNS.address.test(value)) {
              fieldErrors.address = 'Address must be 1-200 characters';
            } else {
              delete fieldErrors.address;
            }
            break;

          case 'missionSupportName':
            if (value && !VALIDATION_PATTERNS.missionSupportName.test(value)) {
              fieldErrors.missionSupportName = 'Must be 0-200 characters (letters, numbers, spaces, hyphens, periods, commas)';
            } else {
              delete fieldErrors.missionSupportName;
            }
            break;

          case 'otherAmount':
            if (showOtherInput && !value.trim()) {
              fieldErrors.otherAmount = 'Please enter an amount';
            } else if (value && !VALIDATION_PATTERNS.amount.test(value)) {
              fieldErrors.otherAmount = 'Invalid amount format';
            } else if (value) {
              const amount = parseFloat(value);
              if (isNaN(amount) || amount < AMOUNT_CONFIG.MIN || amount > AMOUNT_CONFIG.MAX) {
                fieldErrors.otherAmount = `Amount must be between $${AMOUNT_CONFIG.MIN} and $${AMOUNT_CONFIG.MAX}`;
              } else {
                delete fieldErrors.otherAmount;
              }
            } else {
              delete fieldErrors.otherAmount;
            }
            break;
        }

        setErrors(fieldErrors);
        return Object.keys(fieldErrors).length === 0;
      }

      function sanitizeAmount(inputValue) {
        if (!inputValue || typeof inputValue !== 'string') return null;

        let sanitized = inputValue.trim().replace(/\s+/g, '');
        sanitized = sanitized.replace(/[$,\s]/g, '');

        if (!VALIDATION_PATTERNS.amount.test(sanitized)) return null;

        const amount = parseFloat(sanitized);
        if (isNaN(amount) || amount < AMOUNT_CONFIG.MIN || amount > AMOUNT_CONFIG.MAX) return null;

        return Math.round(amount * 100) / 100;
      }

      function handleInputChange(name, value) {
        const updatedData = { ...formData, [name]: value };
        setFormData(updatedData);
        validateField(name, value);
        saveFormToSession(updatedData);
      }

      function handlePresetClick(amount) {
        setSelectedPreset(amount);
        setShowOtherInput(false);
        setFormData(prev => ({ ...prev, amount, otherAmount: '' }));
        setErrors(prev => {
          const newErrors = { ...prev };
          delete newErrors.otherAmount;
          return newErrors;
        });
        saveFormToSession({ ...formData, amount, otherAmount: '' });
      }

      function handleOtherClick() {
        setSelectedPreset(null);
        setShowOtherInput(true);
        setFormData(prev => ({ ...prev, amount: null }));
        setTimeout(() => {
          const otherInput = document.getElementById('other-amount-input');
          if (otherInput) otherInput.focus();
        }, 100);
      }

      function handleOtherAmountChange(value) {
        handleInputChange('otherAmount', value);
        const sanitized = sanitizeAmount(value);
        if (sanitized) {
          setFormData(prev => ({ ...prev, amount: sanitized }));
          saveFormToSession({ ...formData, amount: sanitized, otherAmount: value });
        }
      }

      async function handleSubmit(e) {
        e.preventDefault();
        setIsSubmitting(true);

        // Validate all fields
        const firstNameValid = validateField('firstName', formData.firstName);
        const lastNameValid = validateField('lastName', formData.lastName);
        const emailValid = validateField('email', formData.email);
        const addressValid = validateField('address', formData.address);
        const missionSupportNameValid = validateField('missionSupportName', formData.missionSupportName);

        // Validate amount
        let amountValid = false;
        let finalAmount = null;

        if (selectedPreset) {
          finalAmount = selectedPreset;
          amountValid = true;
        } else if (showOtherInput && formData.otherAmount) {
          const sanitized = sanitizeAmount(formData.otherAmount);
          if (sanitized) {
            finalAmount = sanitized;
            amountValid = true;
          } else {
            validateField('otherAmount', formData.otherAmount);
            amountValid = false;
          }
        } else {
          setErrors(prev => ({ ...prev, amount: 'Please select or enter an amount' }));
          amountValid = false;
        }

        if (!firstNameValid || !lastNameValid || !emailValid || !addressValid || !missionSupportNameValid || !amountValid) {
          setIsSubmitting(false);
          return;
        }

        // Prepare form data for storage and backend
        const submissionData = {
          firstName: formData.firstName.trim(),
          lastName: formData.lastName.trim(),
          email: formData.email.trim().toLowerCase(),
          address: formData.address.trim(),
          missionSupportName: formData.missionSupportName.trim() || null,
          amount: finalAmount,
          timestamp: new Date().toISOString(),
          source: 'missionSupportForm'
        };

        // Store in session
        saveFormToSession(submissionData);

        // Store amount separately for payment flow
        try {
          if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_donation', JSON.stringify({
              amount: finalAmount,
              timestamp: new Date().toISOString(),
              source: 'mission_support_form'
            }));
          }
          if (typeof sessionStorage !== 'undefined') {
            sessionStorage.setItem('hingecraft_donation', JSON.stringify({
              amount: finalAmount,
              timestamp: new Date().toISOString(),
              source: 'mission_support_form'
            }));
          }
        } catch (e) {
          console.error('Error storing donation amount:', e);
        }

        // Log to backend (non-blocking)
        try {
          const sessionID = generateSessionId();
          const anonymousFingerprint = getAnonymousFingerprint();
          
          // Call backend function
          if (typeof wixFetch !== 'undefined') {
            wixFetch.fetch('/_functions/logMissionSupportIntent', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                formData: submissionData,
                amountEntered: finalAmount,
                timestamp: submissionData.timestamp,
                sessionID: sessionID,
                anonymousFingerprint: anonymousFingerprint,
                referrerSource: document.referrer || 'direct',
                pageUrl: window.location.href,
                userAgent: navigator.userAgent
              })
            }).catch(err => console.error('Backend logging error (non-blocking):', err));
          } else {
            // Fallback to fetch
            fetch('/_functions/logMissionSupportIntent', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                formData: submissionData,
                amountEntered: finalAmount,
                timestamp: submissionData.timestamp,
                sessionID: sessionID,
                anonymousFingerprint: anonymousFingerprint,
                referrerSource: document.referrer || 'direct',
                pageUrl: window.location.href,
                userAgent: navigator.userAgent
              })
            }).catch(err => console.error('Backend logging error (non-blocking):', err));
          }
        } catch (e) {
          console.error('Error logging intent:', e);
        }

        // Handle payment method selection
        if (paymentMethod === 'crypto') {
          // Create NOWPayments invoice
          try {
            const sessionID = generateSessionId();
            
            // Call Wix backend function
            let invoiceResponse;
            if (typeof wixFetch !== 'undefined') {
              invoiceResponse = await wixFetch.fetch('/_functions/createNowPaymentsInvoice', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  intentId: sessionID, // Use sessionID as intentId for now
                  amount: finalAmount,
                  email: submissionData.email,
                  sessionId: sessionID,
                  firstName: submissionData.firstName,
                  lastName: submissionData.lastName,
                  missionSupportName: submissionData.missionSupportName
                })
              });
            } else {
              invoiceResponse = await fetch('/_functions/createNowPaymentsInvoice', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  intentId: sessionID,
                  amount: finalAmount,
                  email: submissionData.email,
                  sessionId: sessionID,
                  firstName: submissionData.firstName,
                  lastName: submissionData.lastName,
                  missionSupportName: submissionData.missionSupportName
                })
              });
            }

            const invoiceData = await invoiceResponse.json();
            
            if (invoiceData.success && invoiceData.paymentUrl) {
              // Store invoice data in session
              try {
                if (typeof wixStorage !== 'undefined' && wixStorage.session) {
                  wixStorage.session.setItem('hc_nowpay_invoice', JSON.stringify({
                    invoiceId: invoiceData.invoiceId,
                    paymentUrl: invoiceData.paymentUrl,
                    orderId: invoiceData.orderId,
                    intentId: invoiceData.intentId
                  }));
                }
                if (typeof sessionStorage !== 'undefined') {
                  sessionStorage.setItem('hc_nowpay_invoice', JSON.stringify({
                    invoiceId: invoiceData.invoiceId,
                    paymentUrl: invoiceData.paymentUrl,
                    orderId: invoiceData.orderId,
                    intentId: invoiceData.intentId
                  }));
                }
              } catch (e) {
                console.error('Error storing invoice data:', e);
              }

              // Redirect to NOWPayments invoice page
              if (typeof wixLocation !== 'undefined' && wixLocation.to) {
                wixLocation.to(invoiceData.paymentUrl);
              } else {
                window.location.href = invoiceData.paymentUrl;
              }
              return;
            } else {
              throw new Error(invoiceData.error || 'Failed to create crypto invoice');
            }
          } catch (cryptoError) {
            console.error('Crypto invoice creation error:', cryptoError);
            setErrors(prev => ({ ...prev, payment: 'Failed to create crypto payment. Please try again or select card payment.' }));
            setIsSubmitting(false);
            return;
          }
        } else {
          // Card payment: Redirect to Charter Page with amount
          // Note: Mission Support form is now on Payment page URL (/payment)
          const charterUrl = `/charter?donationAmount=${encodeURIComponent(finalAmount)}&fromMissionSupport=true&paymentMethod=card`;
          
          if (typeof wixLocation !== 'undefined' && wixLocation.to) {
            wixLocation.to(charterUrl);
          } else {
            window.location.href = charterUrl;
          }
        }
      }

      function generateSessionId() {
        try {
          if (typeof sessionStorage !== 'undefined') {
            let sessionId = sessionStorage.getItem('hingecraft_session_id');
            if (sessionId) return sessionId;
          }
          const sessionId = 'hc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          if (typeof sessionStorage !== 'undefined') {
            sessionStorage.setItem('hingecraft_session_id', sessionId);
          }
          return sessionId;
        } catch (e) {
          return 'hc_' + Date.now();
        }
      }

      function getAnonymousFingerprint() {
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          ctx.textBaseline = 'top';
          ctx.font = '14px Arial';
          ctx.fillText('HingeCraft', 2, 2);
          return btoa(canvas.toDataURL().substring(0, 50)).substring(0, 16);
        } catch (e) {
          return 'fp_' + Math.random().toString(36).substr(2, 9);
        }
      }

      return (
        <div className="w-full max-w-3xl mx-auto p-4 sm:p-6 bg-white text-slate-900 rounded-lg shadow-lg">
          <h1 className="text-3xl font-bold mb-6 text-center">MISSION SUPPORT</h1>
          
          <form onSubmit={handleSubmit} className="space-y-6">
            {/* First Name */}
            <div>
              <label htmlFor="firstName" className="block text-sm font-medium mb-1">
                First Name <span className="text-rose-600">*</span>
              </label>
              <input
                id="firstName"
                type="text"
                value={formData.firstName}
                onChange={(e) => handleInputChange('firstName', e.target.value)}
                className={`w-full border rounded-lg px-3 py-2 ${errors.firstName ? 'border-rose-500' : 'border-slate-300'}`}
                placeholder="Enter your first name"
                required
              />
              {errors.firstName && <p className="mt-1 text-sm text-rose-600">{errors.firstName}</p>}
            </div>

            {/* Last Name */}
            <div>
              <label htmlFor="lastName" className="block text-sm font-medium mb-1">
                Last Name <span className="text-rose-600">*</span>
              </label>
              <input
                id="lastName"
                type="text"
                value={formData.lastName}
                onChange={(e) => handleInputChange('lastName', e.target.value)}
                className={`w-full border rounded-lg px-3 py-2 ${errors.lastName ? 'border-rose-500' : 'border-slate-300'}`}
                placeholder="Enter your last name"
                required
              />
              {errors.lastName && <p className="mt-1 text-sm text-rose-600">{errors.lastName}</p>}
            </div>

            {/* Email */}
            <div>
              <label htmlFor="email" className="block text-sm font-medium mb-1">
                Email <span className="text-rose-600">*</span>
              </label>
              <input
                id="email"
                type="email"
                value={formData.email}
                onChange={(e) => handleInputChange('email', e.target.value)}
                className={`w-full border rounded-lg px-3 py-2 ${errors.email ? 'border-rose-500' : 'border-slate-300'}`}
                placeholder="Enter your email address"
                required
              />
              {errors.email && <p className="mt-1 text-sm text-rose-600">{errors.email}</p>}
            </div>

            {/* Address */}
            <div>
              <label htmlFor="address" className="block text-sm font-medium mb-1">
                Address <span className="text-rose-600">*</span>
              </label>
              <input
                id="address"
                type="text"
                value={formData.address}
                onChange={(e) => handleInputChange('address', e.target.value)}
                className={`w-full border rounded-lg px-3 py-2 ${errors.address ? 'border-rose-500' : 'border-slate-300'}`}
                placeholder="Enter your address"
                required
              />
              {errors.address && <p className="mt-1 text-sm text-rose-600">{errors.address}</p>}
            </div>

            {/* Mission Support in the name of */}
            <div>
              <label htmlFor="missionSupportName" className="block text-sm font-medium mb-1">
                Mission Support in the name of
              </label>
              <input
                id="missionSupportName"
                type="text"
                value={formData.missionSupportName}
                onChange={(e) => handleInputChange('missionSupportName', e.target.value)}
                className={`w-full border rounded-lg px-3 py-2 ${errors.missionSupportName ? 'border-rose-500' : 'border-slate-300'}`}
                placeholder="Optional: Enter name for attribution or dedication"
                maxLength={200}
              />
              {errors.missionSupportName && <p className="mt-1 text-sm text-rose-600">{errors.missionSupportName}</p>}
            </div>

            {/* Payment Method Selection */}
            <div className="border-t pt-6">
              <label className="block text-sm font-medium mb-3">
                Payment Method <span className="text-rose-600">*</span>
              </label>
              
              <div className="grid grid-cols-2 gap-3 mb-6">
                <button
                  type="button"
                  onClick={() => setPaymentMethod('card')}
                  className={`px-4 py-3 border rounded-lg font-semibold transition ${
                    paymentMethod === 'card'
                      ? 'border-slate-900 bg-slate-900 text-white'
                      : 'border-slate-300 hover:border-slate-500'
                  }`}
                >
                  ðŸ’³ Card Payment
                </button>
                <button
                  type="button"
                  onClick={() => setPaymentMethod('crypto')}
                  className={`px-4 py-3 border rounded-lg font-semibold transition ${
                    paymentMethod === 'crypto'
                      ? 'border-slate-900 bg-slate-900 text-white'
                      : 'border-slate-300 hover:border-slate-500'
                  }`}
                >
                  â‚¿ Crypto Payment
                </button>
              </div>

              {paymentMethod === 'crypto' && (
                <div className="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                  <p className="text-sm text-blue-800">
                    <strong>Crypto Payment:</strong> You will be redirected to a secure crypto payment page where you can pay with Bitcoin, Ethereum, Solana, or other supported cryptocurrencies.
                  </p>
                </div>
              )}
            </div>

            {/* Payment Amount Section */}
            <div className="border-t pt-6">
              <label className="block text-sm font-medium mb-3">
                Default payment amount of
              </label>
              
              <div className="grid grid-cols-3 gap-3 mb-4">
                {AMOUNT_CONFIG.PRESETS.map(amount => (
                  <button
                    key={amount}
                    type="button"
                    onClick={() => handlePresetClick(amount)}
                    className={`px-4 py-3 border rounded-lg font-semibold transition ${
                      selectedPreset === amount
                        ? 'border-slate-900 bg-slate-900 text-white'
                        : 'border-slate-300 hover:border-slate-500'
                    }`}
                  >
                    ${amount}
                  </button>
                ))}
                <button
                  type="button"
                  onClick={handleOtherClick}
                  className={`px-4 py-3 border rounded-lg font-semibold transition ${
                    showOtherInput
                      ? 'border-slate-900 bg-slate-900 text-white'
                      : 'border-slate-300 hover:border-slate-500'
                  }`}
                >
                  Other
                </button>
              </div>

              {showOtherInput && (
                <div>
                  <label htmlFor="other-amount-input" className="block text-sm font-medium mb-1">
                    Enter custom amount <span className="text-rose-600">*</span>
                  </label>
                  <input
                    id="other-amount-input"
                    type="text"
                    value={formData.otherAmount}
                    onChange={(e) => handleOtherAmountChange(e.target.value)}
                    className={`w-full border rounded-lg px-3 py-2 ${errors.otherAmount ? 'border-rose-500' : 'border-slate-300'}`}
                    placeholder={`$${AMOUNT_CONFIG.MIN} - $${AMOUNT_CONFIG.MAX.toLocaleString()}`}
                    required={showOtherInput}
                  />
                  {errors.otherAmount && <p className="mt-1 text-sm text-rose-600">{errors.otherAmount}</p>}
                  {errors.amount && <p className="mt-1 text-sm text-rose-600">{errors.amount}</p>}
                </div>
              )}
            </div>

            {/* Submit Button */}
            <button
              type="submit"
              disabled={isSubmitting}
              className="w-full px-6 py-3 bg-slate-900 text-white rounded-lg font-semibold hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed transition"
            >
              {isSubmitting 
                ? 'Processing...' 
                : paymentMethod === 'crypto' 
                  ? 'Continue to Crypto Payment' 
                  : 'Continue to Charter Page'}
            </button>

            {errors.payment && (
              <p className="mt-2 text-sm text-rose-600 text-center">{errors.payment}</p>
            )}
          </form>

          {sessionRestored && (
            <p className="mt-4 text-xs text-slate-500 text-center">
              Form data restored from previous session
            </p>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<MissionSupportForm />);
  </script>
  
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</body>
</html>

