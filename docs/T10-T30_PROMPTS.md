# HingeCraft T10-T30 Ultra-Detailed Prompts
## Universal Multi-Currency Redirect Engine (UMCRE) Implementation

This document contains 21 comprehensive prompts (T10-T30) for implementing the complete HingeCraft payment system with dynamic currency routing, database integration, and full Wix Velo compatibility.

---

## T10 â€” Full Repository Inventory & Immediate Guard Patch

**Paragraph 1 â€” Inventory & Access:**
Using only the HingeCraft database and the repository checked into the project root at `/Users/chandlerfergusen/Desktop/CURSOR/hingecraft-global`, produce a complete inventory of every file that touches the Charter page, master page, or payment flow. Include file paths (exact), last modified timestamps, and recent commit hashes (or last edit metadata) for `masterPage.js`, `pa3z2.js`, any `charter_page_middleware_web` module, and any payment library or connector. Report missing files or modules. If any of these are generated by Wix build steps, include the original source file locations (e.g., `src/pages/charter/charterPage.jsx`), and the build artifact locations. Output a CSV file `file_inventory.csv` with columns: `path`, `last_modified`, `commit_hash`, `owner_hint`, `line_count`, `file_type`, `build_source` (if applicable).

**Paragraph 2 â€” Static Symbol Analysis:**
Run a static AST analysis on each file identified in Paragraph 1 to list exported and imported symbols. For each import referencing `charter_page_middleware_web`, produce the exact text of the import (line and column), the resolved path, and the export shape discovered in the exporting module. If `onReady` is absent, list alternative function names or default exports. Provide a diff patch suggestion for re-exporting `onReady` to maintain compatibility (show exact code block to add). Output `exports_map.json` showing module name â†’ exported symbols array, and `import_analysis.json` showing all imports of `charter_page_middleware_web` with their call sites.

**Paragraph 3 â€” Immediate Guard Fix:**
If the live site currently crashes with `TypeError: (0 , charter_page_middleware_web.onReady) is not a function`, automatically create a branch `hotfix/guard-onready` and add the defensive guard snippet into `pa3z2.js` (or the compiled bundle location). The guard must check for `charter_page_middleware_web` existence, verify `onReady` is a function, and handle both named and default export patterns. Create a PR description that includes the exact console stack trace, the reason for the guard (named/default export mismatch, bundler transformation, or circular dependency), and a link to the module analysis from Paragraph 2.

**Paragraph 4 â€” Deliverables & Tests:**
Produce these artifacts in the PR: `exports_map.json`, `import_analysis.json`, the guard patch (unified diff), and a smoke test script `test/smoke_check_charter.js` that loads the charter page in a headless browser (Puppeteer/Playwright) and asserts no uncaught `TypeError` occurs within 5 seconds of page load. Output test results in `smoke_result.json` with pass/fail status, error messages (if any), and console logs captured. Include instructions for running the smoke test locally and in CI.

---

## T11 â€” HingeCraft Database Extraction & Normalization

**Paragraph 1 â€” Database Extraction:**
Run the exact SQL/Mongo exports provided in `scripts/extract_database_urls.sql` and `scripts/extract_database_urls_mongo.js` against the HingeCraft database. Extract all records containing `payment_url`, `invoice_url`, `wallet_address`, `checkout_url`, `session_id`, `provider_id`, and any `provider_payload` or `metadata` fields that contain JSON with HTTP/HTTPS URLs. Output `hingecraft_payments.csv`, `hingecraft_wallets.csv`, `hingecraft_external_payments.csv`, `hingecraft_crypto_payments.csv`, and `hingecraft_stripe_payments.csv`. For each CSV, include columns: `id`, `created_at`, `gateway`, `currency`, `amount`, `payment_url`, `invoice_url`, `wallet_address`, `status`, `metadata` (as JSON string), and any provider-specific fields.

**Paragraph 2 â€” Normalization & Pattern Extraction:**
For each record extracted in Paragraph 1, parse JSON metadata fields (`metadata`, `provider_payload`, `raw_response`) to extract nested `invoice_url`, `checkout_url`, `payment_url`, `pay_address`, `currency`, `amount`, `provider`, `provider_invoice_id`, `session_id`. Normalize currency codes to ISO 4217 (e.g., "usd" â†’ "USD", "btc" â†’ "BTC"). Create `normalized_payments.csv` with columns: `local_id`, `provider` (stripe/nowpayments/wallet), `provider_invoice_id`, `provider_url` (the actual payment URL), `currency`, `amount`, `payment_method` (card/ach/crypto), `created_at`, `last_used`, `usage_count`. Group by `currency` and `provider` to identify the most frequently used URLs per currency.

**Paragraph 3 â€” Mapping to Front-End Components:**
Match each `provider_url` from `normalized_payments.csv` to a front-end element in the repository. Search the repo for that exact URL or parts of it (domain, path segments). Where a URL is present in DB but not referenced in the repo, propose target DOM locations (Charter CTA button, fallback CTA, admin panel, payment confirmation page). Output `mapping_suggestions.csv` with columns: `provider_url`, `found_in_file` (file path if found, else "NOT_FOUND"), `selector_suggestion` (e.g., "#mainPayButton", ".payment-cta"), `priority` (1=high, 2=medium, 3=low), `recommended_action` (use_existing, create_new, update_existing).

**Paragraph 4 â€” Acceptance Criteria:**
Return `normalized_payments.csv` and `mapping_suggestions.csv`. The indicator `ready_to_map` equals `true` when every currency in the currency list (USD, EUR, BTC, ETH, SOL, XLM, etc.) has at least one `provider_url` mapped to a front-end CTA or a clear suggestion for where to add it. For currencies without URLs, flag them with `action_required: "CREATE_INVOICE_OR_SESSION"` and provide the exact API call needed (Stripe session creation or NOWPayments invoice creation) with sample parameters.

---

## T12 â€” Build payment-currency-map.json & Currency Router Module

**Paragraph 1 â€” Build Centralized Map:**
Using `normalized_payments.csv` from T11, build `public/payment-currency-map.json` that maps every currency to a prioritized list of provider URLs and provider names (Stripe/NowPayments/Wallet). Format per currency: `{ "USD": [ {"provider":"stripe","url":"https://checkout.stripe.com/pay/...","priority":1,"method":"card"}, {"provider":"stripe","url":"https://checkout.stripe.com/pay/...","priority":2,"method":"ach"} ], "BTC": [ {"provider":"nowpayments","url":"https://nowpayments.io/payment/...","priority":1,"coin":"bitcoin"}, {"provider":"wallet","url":"bc1q...","priority":2,"coin":"bitcoin"} ] }`. Include metadata: `last_verified`, `usage_count`, `test_mode` (boolean), `expires_at` (if applicable). Validate JSON schema with `ajv` and ensure all URLs are HTTPS and from allowed domains (stripe.com, nowpayments.io, or wallet addresses).

**Paragraph 2 â€” Create Currency Router Module:**
Create `public/currencyRouter.js` (or `src/backend/currencyRouter.web.js` for Wix Velo) that (a) reads `payment-currency-map.json` (either via fetch or inline import), (b) exposes `initCurrencyRouter({ selectId, ctaId, defaultCurrency })` to set CTA link dynamically, (c) supports query-param preselection (`?currency=EUR`), (d) persists user selection to `localStorage` with key `hingecraft_selected_currency`, and (e) emits analytics events `currency_selected` and `cta_url_updated` with GTM/analytics integration. The router must handle both Wix Velo `$w` elements and custom DOM elements (fallback for embedded HTML). Include error handling for missing currencies, invalid URLs, and network failures when fetching the map.

**Paragraph 3 â€” Unit & Integration Tests:**
Add Jest unit tests `jest/currencyRouter.spec.js` that assert: selecting 'BTC' returns NOWPayments invoice URL from the map; invalid currency returns USD mapping (fallback); mapping JSON schema is validated with `ajv`; `localStorage` persistence works; query param `?currency=EUR` sets dropdown and CTA correctly. Add E2E Cypress tests `cypress/integration/charter_currency_spec.js` that run on the test Wix site and verify: CTA link updates on dropdown change (assert `button.link === expected` or `anchor.href === expected`); clicking CTA navigates to the correct payment provider URL; selection persists on page reload; all currencies in the map have working CTAs.

**Paragraph 4 â€” Documentation & Commit:**
Commit files to branch `feature/currency-router` with commit message: "feat: Add centralized currency routing with payment-currency-map.json". Include `README.md` in `public/` with instructions: how to add new providers (edit JSON, add URL, set priority), how to add a currency via the HingeCraft admin panel (which calls the router's update function), migration steps for existing hardcoded URLs, and troubleshooting (check browser console for router logs, verify JSON is accessible, check CTA element IDs match). Add a changelog entry documenting the new routing system.

---

## T13 â€” Fix onReady Root Cause & Re-Export Compatibility

**Paragraph 1 â€” Hypothesis & Automated Checks:**
Enumerate 6 possible causes for `TypeError: (0 , charter_page_middleware_web.onReady) is not a function`: (1) missing export (function not exported), (2) wrong import style (named vs default), (3) bundler alias/transformation (ESM â†’ CommonJS mismatch), (4) tree-shaken export (unused export removed), (5) object renamed in build (minification), (6) runtime order (circular dependency or module not loaded). For each cause, provide a one-liner check you can run in devtools or in build environment and the expected result. Generate `module_report.txt` that lists modules transpiled by bundler (Wix Velo build system), whether they export default or named exports, and any interop wrappers detected.

**Paragraph 2 â€” Minimal Code Fixes (Three Variants):**
Provide three alternate safe implementations: (A) Fix module to export `onReady` as named export at source (`charter-page-middleware.web.js`): add `export async function onReady() { ... }` if missing, or change `export default { onReady }` to `export { onReady }`. (B) Change import sites to use `.default.onReady` if necessary: in `pa3z2.js` or wherever it's imported, change `charter_page_middleware_web.onReady()` to `(charter_page_middleware_web.default || charter_page_middleware_web).onReady()`. (C) Wrap caller invocation in a small helper `safeInvoke(module, 'onReady')` (temporary): create `utils/safeInvoke.js` that checks for function existence and handles both patterns. Provide exact code patches for each approach in unified diff format, with line numbers and context.

**Paragraph 3 â€” Test Harness & Module Inspection:**
Create `charter_test.html` (standalone test page) that imports the built bundle and logs `typeof charter_page_middleware_web`, `Object.keys(charter_page_middleware_web)`, and asserts `typeof charter_page_middleware_web.onReady === 'function'`. Include a Node script `test/inspect_module.js` to `require`/`esm-load` the module and print the export shape (use `Object.getOwnPropertyNames`, `Object.getOwnPropertyDescriptors`). Run this on both the source module and the compiled bundle to identify where the export is lost or transformed.

**Paragraph 4 â€” Rollout & Monitoring:**
Open PR `fix/onready-exports` with choice A (fix export) by default, and include migration notes for teams using the module. Add Sentry rule (or equivalent monitoring) to alert on `TypeError: onReady` in production: create error filter matching `"onReady"` and `"is not a function"`, send Slack alert with compressed stack trace and session ID. After merge and deploy, remove the guard snippet from T10 in a follow-up PR `chore/remove-onready-guard` once monitoring confirms no errors for 7 days.

---

## T14 â€” NOWPayments Invoice Generator & URL Persistence

**Paragraph 1 â€” Server-Side Invoice Creation:**
Create server-side function `create_nowpayment_invoice.js` (or integrate into `nowpayments.api.jsw`) using the Node template from `scripts/nowpayments_invoice_creator.js`. The function must accept parameters: `amount` (number), `fiatCurrency` (string, default "USD"), `payCurrency` (string, e.g., "BTC", "ETH", "SOL", "XLM"), `orderId` (string, unique), `successUrl` (string), `cancelUrl` (string). Call NOWPayments API `POST /v1/invoice` with headers `x-api-key` (from Wix Secrets), `Content-Type: application/json`, and body containing all parameters plus `ipn_callback_url` pointing to `/_functions/webhooks/nowpayments`. Handle API errors (rate limits, invalid currency, network failures) with exponential backoff retry (3 attempts, 1s/2s/4s delays).

**Paragraph 2 â€” Database Persistence:**
After successful invoice creation, persist `invoice_url`, `pay_address`, `pay_amount_crypto`, `pay_currency`, `invoice_id`, `order_id`, `expires_at` to HingeCraft database. Write to `CryptoPayments` collection with fields: `intent_id` (link to `ContributionIntent` if exists), `order_id`, `invoice_id`, `payment_url` (the NOWPayments invoice URL), `pay_address`, `pay_amount_crypto`, `pay_currency`, `price_amount`, `price_currency`, `status` ("pending"), `invoice_created_at`, `invoice_expires_at`, `raw_response` (full API response as JSON). Also update `external_payments` collection with `gateway: "nowpayments"`, `provider_id: invoice_id`, `provider_payload: { invoice_url, pay_address, ... }`.

**Paragraph 3 â€” Integration with Currency Router:**
Link the invoice creation to the currency router: when user selects a crypto currency (BTC, ETH, SOL, XLM) and clicks the CTA, call `create_nowpayment_invoice` with the donation amount, store the returned `invoice_url` in state, and update the CTA button's `href` or `link` property to the `invoice_url`. If invoice creation fails, show user-friendly error message and allow retry. Add loading state during invoice creation (disable button, show spinner). Store invoice data in `sessionStorage` with key `hingecraft_crypto_invoice` so it persists across page refreshes.

**Paragraph 4 â€” Testing & Dry Run:**
Run a dry test to create one invoice for BTC in dev/test mode: call the function with `amount: 1`, `fiatCurrency: "USD"`, `payCurrency: "BTC"`, `orderId: "test_${Date.now()}"`. Verify the API returns `invoice_url` and `pay_address`. Check database records are created correctly. Verify the invoice URL is accessible and shows the correct amount and wallet address. Document the test results in `test_results/nowpayments_invoice_test.json` with request/response payloads, database records created, and any errors encountered.

---

## T15 â€” Stripe Session Reconciler & Test Mode Setup

**Paragraph 1 â€” Stripe Reconciliation:**
Using Stripe test keys (from Wix Secrets: `STRIPE_SECRET_TEST`), call `stripe.checkout.sessions.retrieve(session_id)` for each `provider_id` in `external_payments` collection where `gateway = "stripe"` and `checkout_url` is missing or null. For each session, extract `url` (checkout URL), `status`, `amount_total`, `currency`, `payment_status`, `payment_method_types`. Update the local database record with `checkout_url: session.url`, `status: session.status`, and update `provider_payload` to include full session object. Create `stripe_recon.csv` with columns: `local_id`, `provider_id` (session ID), `amount`, `currency`, `status`, `checkout_url`, `reconciled_at`, `mismatch_flag` (true if amount/currency/status differs significantly from local record).

**Paragraph 2 â€” Test Mode Configuration:**
Describe exact steps to enable test mode calls from the site: (a) set environment variable `NODE_ENV=test` in Wix Secrets or site settings, (b) inject `STRIPE_SECRET_TEST=sk_test_...` into serverless secrets (Wix Secrets Manager), (c) configure `STRIPE_WEBHOOK_SECRET=whsec_...` from Stripe Dashboard â†’ Developers â†’ Webhooks â†’ Test mode endpoint, (d) use Stripe CLI `stripe listen --forward-to localhost:3000/_functions/webhooks/stripe` to test webhooks locally, (e) update `stripe.api.jsw` to use test key when `NODE_ENV === "test"` or when `STRIPE_SECRET_TEST` is present. Provide a checklist `STRIPE_TEST_MODE_CHECKLIST.md` with all steps and verification commands.

**Paragraph 3 â€” Session Creation for Currency Router:**
Modify `stripe.api.jsw/createCheckoutSession` to accept any `amount` (not just presets) and `paymentMethod` ('card' or 'ACH'). When creating a session, store the returned `session.url` in the database (`StripePayments` collection) and return it to the frontend. The frontend currency router should use this URL to update the CTA button. For test mode, use test success/cancel URLs that point to test site pages. Add metadata to session: `source: "charter_page"`, `amount`, `currency`, `paymentMethod`, `tier` (if applicable).

**Paragraph 4 â€” Audit Trail & Verification:**
Add an audit table `payment_audit` (or use existing `external_payments` with audit fields) with columns: `id`, `source` (stripe/nowpayments), `payload` (JSON of request/response), `attempt_count`, `last_attempt_at`, `status` (success/failed), `error_message`. Provide SQL/NoSQL insert statements and a DB job (cron or scheduled function) to reconcile every 15 minutes: fetch all pending payments, call provider APIs to get current status, update local records, log reconciliation attempts in audit table. Create a dashboard query to show reconciliation success rate and any persistent mismatches.

---

## T16 â€” Map Database Results into paymentRoutes Object

**Paragraph 1 â€” Generate paymentRoutes from Normalized Data:**
Take `payment-currency-map.json` from T12 and `normalized_payments.csv` from T11, and produce a `paymentRoutes` JavaScript object (as a stringified JSON or as a JS module) to paste into `charter-page-wix-ready.html` or host as `public/paymentRoutes.json`. The object should have the structure: `{ "SOL_USDC": { type: "crypto", provider: "nowpayments", coin: "solana", currency: "SOL", url: "https://nowpayments.io/payment/...", walletAddress: "..." }, "CARD": { type: "fiat", provider: "stripe", method: "card", currency: "USD", url: "https://checkout.stripe.com/pay/..." } }`. For each currency/rail combination, use the highest priority URL from the map. If multiple URLs exist, prefer the most recently used one (from `last_used` in normalized data).

**Paragraph 2 â€” URL Validation & Health Checks:**
Validate each mapping by making HEAD requests to all URLs in `paymentRoutes`. Use the crawler from `scripts/crawl_all_resources.js` to check: HTTP status (200-399 = valid), redirect chain (follow up to 10 redirects), SSL certificate validity (not expired, valid chain), response time (< 3s = good, > 10s = slow). Flag URLs with non-2xx status, expired SSL, or slow responses. For flagged URLs, either remove them from the map (if alternatives exist) or mark them with `needs_verification: true` and provide manual verification steps. Output `payment_routes_validation.json` with validation results for each URL.

**Paragraph 3 â€” Dynamic URL Generation (Fallback):**
For currencies that don't have pre-existing URLs in the database (new currencies or test scenarios), provide a fallback mechanism: if `paymentRoutes[currency].url` is null or empty, the currency router should call the appropriate API (NOWPayments invoice creation or Stripe session creation) on-the-fly when the user selects that currency. Store the generated URL in `sessionStorage` and update the CTA. Document this fallback behavior in the router's README and add a flag `allow_dynamic_generation: true` in the router config.

**Paragraph 4 â€” Integration with Charter Page:**
Update `charter-page-wix-ready.html` to load `paymentRoutes` either from an inline `<script>` tag (for immediate availability) or via `fetch('/paymentRoutes.json')` on page load. Merge the loaded routes with any hardcoded fallbacks. Call `updatePaymentButtonForRail(rail)` whenever the rail selection changes, which reads from `paymentRoutes[rail]` and updates the CTA button's URL. Add console logging for debugging: log the selected rail, the route found, and the URL set. Test with all currencies to ensure every rail has a valid URL or a clear error message if missing.

---

## T17 â€” End-to-End Tests for Currency Routing

**Paragraph 1 â€” Cypress Test Suite Setup:**
Write Cypress tests `cypress/integration/charter_currency_spec.js` that run against the test Wix site (not Preview, as Preview has limitations). The suite should: (a) visit the Charter page URL, (b) wait for page load and assert no JavaScript errors in console (use `cy.window().then(win => { win.addEventListener('error', ...) })`), (c) assert the currency selector dropdown/buttons are visible and interactive, (d) assert the main CTA button exists and has an initial state (either disabled or with a default URL).

**Paragraph 2 â€” Currency Selection & CTA Update Tests:**
For each currency in `payment-currency-map.json`, write a test that: (a) selects the currency (click the currency button or change dropdown), (b) waits for the CTA to update (assert `cy.get('#mainPayButton').should('have.attr', 'href', expectedUrl)` or `cy.get('#mainPayButton').invoke('attr', 'link').should('eq', expectedUrl)` for Wix elements), (c) verifies the button text changes appropriately (e.g., "Pay with BTC âš¡" for crypto, "Pay with Card ðŸ’³" for Stripe), (d) verifies the button styling changes (background color, border) based on currency type. Use `paymentRoutes` from T16 to get expected URLs. Handle both scenarios: URLs pre-populated from database, and URLs generated dynamically.

**Paragraph 3 â€” Payment Flow Simulation:**
For each currency, simulate clicking the CTA button: (a) click the button, (b) verify navigation (either `window.location.href` changes to the payment provider URL, or a new tab/window opens with the provider URL), (c) for Stripe: assert the URL contains `checkout.stripe.com`, (d) for NOWPayments: assert the URL contains `nowpayments.io` or the invoice domain, (e) for wallet addresses: assert the page shows the wallet address and QR code (if applicable). Use `cy.visit()` with `failOnStatusCode: false` to handle external redirects, or use `cy.window().then(win => win.location.href)` to check the current URL. Do not actually complete payments (use test mode or cancel immediately).

**Paragraph 4 â€” Test Reports & CI Integration:**
Run the Cypress suite and generate test reports: `cypress run --reporter json --reporter-options output=test_results/cypress_charter_currency.json`. Parse the JSON to create a summary: total tests, passed, failed, duration. For each failed test, include: test name, error message, screenshot path (if available), video path (if available). Integrate into CI pipeline: add step `npm run cypress:run` to GitHub Actions or equivalent, fail the build if any test fails, upload test artifacts (screenshots, videos) to CI artifacts storage. Create a dashboard or Slack notification that shows test results after each deploy.

---

## T18 â€” Resource Crawler & Link Verification

**Paragraph 1 â€” Crawl Plan & Sources:**
Run the crawler from `scripts/crawl_all_resources.js` over: (a) all HTML files in repo (`public/pages/*.html`, `src/**/*.html`), (b) all database records with HTTP/HTTPS strings (from T11 exports: `hingecraft_payments.csv`, `hingecraft_external_payments.csv`, etc.), (c) all payment and wallet fields (parse JSON metadata columns), (d) all external vendor configs (CI files like `.github/workflows/*.yml`, deploy scripts, environment variable files). Collect unique URLs and normalize them (remove tracking query params like `utm_source`, `ref`, `fbclid`). Output `all_urls.txt` with one URL per line, deduplicated.

**Paragraph 2 â€” Health Check Implementation:**
For each URL in `all_urls.txt`, run a HEAD request (or GET if HEAD fails) with: (a) timeout 15 seconds, (b) follow redirects up to 10 hops (record redirect chain), (c) capture: HTTP status code, final URL after redirects, server header, content-type, TLS expiration date (from certificate), response time (RTT). Use `axios` with `maxRedirects: 10` and `timeout: 15000`. Rate limit to 10 concurrent requests and add 250ms delay between requests to the same hostname (politeness). Use exponential backoff for failed requests (retry up to 3 times with 1s/2s/4s delays).

**Paragraph 3 â€” Verification & Flagging:**
Flag URLs with: (a) non-2xx status codes (404, 500, etc.) as "BROKEN", (b) expired SSL certificates as "SSL_EXPIRED", (c) redirect chains > 5 hops as "TOO_MANY_REDIRECTS", (d) response time > 10s as "SLOW", (e) third-party hosts outside allowed list (stripe.com, nowpayments.io, wix.com, hingecraft-global.ai) as "UNTRUSTED" (for payment URLs, this is critical). Output `resource_report.json` with fields: `url`, `status`, `final_url`, `redirects` (array of redirect chain), `ssl_expiry`, `rtt`, `flags` (array of flags), `notes`. Also output `resource_report.csv` for easy filtering in Excel.

**Paragraph 4 â€” Weekly Automation & Alerts:**
Provide a cron job script `scripts/resources_check.sh` (or GitHub Action workflow) that runs weekly (every Monday at 2 AM UTC). The script should: (a) run the crawler, (b) compare results to previous week's report (stored in `test_results/resource_report_last_week.json`), (c) identify new broken links (URLs that were working last week but are broken now), (d) email `links@hingecraft-global.ai` (or send Slack message to `#hingecraft-payments`) with summary: total URLs checked, new broken links (list with status codes), critical failures (payment provider URLs that are broken), SSL expiring soon (< 30 days). Archive weekly reports in `test_results/resource_reports/` with timestamp.

---

## T19 â€” Webhook Verification & Stripe CLI Testing

**Paragraph 1 â€” Stripe Webhook Signature Verification:**
Add server-side webhook verification code in `webhooks/stripe.jsw` (or equivalent). For each incoming webhook request, verify the Stripe signature: (a) extract `stripe-signature` header, (b) get webhook secret from Wix Secrets (`STRIPE_WEBHOOK_SECRET`), (c) construct the signed payload (timestamp + payload body), (d) compute HMAC SHA256, (e) compare with signature from header. Use Stripe's official library `stripe.webhooks.constructEvent(payload, signature, secret)` if available, or implement manually. Reject requests with invalid signatures (return 401) and log rejection attempts with IP address and timestamp. Accept only events from Stripe's IP ranges (documented in Stripe docs).

**Paragraph 2 â€” NOWPayments Webhook HMAC Verification:**
Add HMAC verification for NOWPayments webhooks in `webhooks/nowpayments.jsw`. NOWPayments signs webhooks with HMAC SHA512 using the API key as the secret. Extract `x-nowpayments-signature` header, compute HMAC of the request body, compare with header value. Reject invalid signatures and log attempts. Document the verification process in `docs/webhook_verification.md` with code examples and test vectors.

**Paragraph 3 â€” Stripe CLI Testing Setup:**
Provide a script `stripe_listen.sh` using Stripe CLI to replay events to staging: (a) install Stripe CLI (`brew install stripe/stripe-cli/stripe` or equivalent), (b) login with test API key (`stripe login --api-key sk_test_...`), (c) forward events to local endpoint (`stripe listen --forward-to localhost:3000/_functions/webhooks/stripe`), (d) trigger test events (`stripe trigger checkout.session.completed`, `stripe trigger payment_intent.succeeded`). Verify the webhook handler receives events, validates signatures, and processes them correctly (updates database, sends confirmation emails, etc.). Document the setup in `docs/stripe_cli_testing.md`.

**Paragraph 4 â€” Webhook Handler Testing:**
Create integration tests for webhook handlers: (a) mock Stripe/NOWPayments webhook payloads (use sample payloads from provider docs), (b) sign them with correct secrets, (c) send POST requests to webhook endpoints, (d) verify handlers return 200, (e) verify database is updated correctly, (f) verify side effects (emails sent, notifications created). Test error scenarios: invalid signature (should return 401), malformed payload (should return 400), duplicate events (should be idempotent). Add tests to `test/integration/webhooks_spec.js` and run in CI.

---

## T20 â€” Payment Audit Table & Reconciliation Job

**Paragraph 1 â€” Audit Table Schema:**
Add `payment_audit` table (or collection) to HingeCraft database with columns: `id` (primary key, auto-increment or UUID), `source` (string: "stripe", "nowpayments", "manual"), `payload` (JSON: full request/response payload), `attempt_count` (integer, default 1), `last_attempt_at` (timestamp), `status` (string: "success", "failed", "pending"), `error_message` (text, nullable), `reconciled_at` (timestamp, nullable), `provider_id` (string, nullable: session_id, invoice_id), `local_payment_id` (foreign key to payments table, nullable). Create indexes on `source`, `status`, `last_attempt_at`, `provider_id` for fast queries. Provide SQL DDL or MongoDB schema.

**Paragraph 2 â€” Reconciliation Job Implementation:**
Create a transactional reconciliation job (scheduled function or cron) that runs every 15 minutes: (a) fetch all pending payments from `payments` or `external_payments` where `status = "pending"` and `created_at > NOW() - INTERVAL 24 HOURS`, (b) for each payment, call the provider API (Stripe `checkout.sessions.retrieve` or NOWPayments `GET /v1/payments/{id}`) to get current status, (c) compare provider status with local status, (d) if mismatch (e.g., provider says "paid" but local says "pending"), update local record and log in audit table, (e) if provider says "failed" or "canceled", update local record and notify user (email or in-app notification), (f) insert audit record with `source`, `payload` (API response), `status`, `reconciled_at`. Use database transactions to ensure atomicity.

**Paragraph 3 â€” Mismatch Detection & Alerts:**
For each reconciliation, detect mismatches: (a) amount mismatch (provider amount differs from local by > $0.01), (b) currency mismatch, (c) status mismatch (provider "paid" but local "pending", or vice versa), (d) missing provider record (local payment exists but provider API returns 404). Flag mismatches with `mismatch_flag: true` in audit table and create a ticket/alert. Send Slack alert to `#hingecraft-payments` with details: payment ID, provider ID, mismatch type, recommended action. For critical mismatches (amount > $100 or status "paid" but local "failed"), send immediate email to `payments@hingecraft-global.ai`.

**Paragraph 4 â€” Monitoring & Dashboard:**
Create a monitoring dashboard query (SQL or aggregation pipeline) that shows: (a) reconciliation success rate (last 24 hours: successful reconciliations / total attempts), (b) pending payments count (payments with status "pending" > 1 hour old), (c) mismatch count (last 7 days), (d) average reconciliation time (time between payment creation and successful reconciliation). Display in admin panel or send weekly summary email. Add Grafana/DataDog metrics if available. Create alerts: if reconciliation success rate < 95% for 1 hour, send alert; if pending payments > 50, send alert.

---

## T21 â€” Canary Deploy & Production Rollout

**Paragraph 1 â€” Pre-Deploy Checklist:**
Before deploying to production, run pre-deploy tests: (a) local unit tests (`npm test`) with coverage > 80%, (b) Cypress E2E tests (`npm run cypress:run`) all passing, (c) audit job run (`npm run audit:payments`) with no critical issues, (d) resource crawler run (`npm run crawl:resources`) with no broken payment URLs, (e) webhook verification tests passing. Staging deploy must be flagged `canary=true` in deployment config. Create a checklist file `DEPLOY_CHECKLIST.md` with all items and verification commands.

**Paragraph 2 â€” Canary Deployment:**
Deploy to test site first (Wix test site or staging environment). Run smoke tests: (a) visit Charter page, (b) select each currency, (c) verify CTA updates correctly, (d) click CTA and verify redirect (do not complete payment). If smoke tests pass, enable canary (10% traffic) on production: route 10% of users to new deployment using feature flag or load balancer config. Run 1k synthetic tests in Canary (use tools like Pingdom, UptimeRobot, or custom script) that simulate user flows. Monitor Sentry for `TypeError: onReady` or broken link errors. If error rate < 0.1% for 1 hour, promote to 100% traffic.

**Paragraph 3 â€” Rollback Procedure:**
If critical errors occur (error rate > 1%, payment failures, broken CTAs), rollback immediately: (a) use Wix CLI `wix deploy --rollback <previous-deploy-id>` or hosting provider's rollback feature, (b) revert feature flag to 0% canary, (c) capture current commit/asset IDs before rollback (save to `rollback_log.json`), (d) notify team via Slack `#hingecraft-deployments` with rollback reason and commit hash. After rollback, investigate root cause, fix in a hotfix branch, and redeploy after verification. Document rollback in `DEPLOY_LOG.md`.

**Paragraph 4 â€” Post-Deploy Verification:**
After successful deploy to 100%, run automated post-deploy checks: (a) page load time < 2s (use Lighthouse or WebPageTest), (b) no `TypeError: onReady` in console (use browser automation to check), (c) CTA mapping correct for 100% of currencies (script enumerates each currency, selects it, checks `button.link` or `anchor.href` equals expected URL from `paymentRoutes`), (d) webhook delivery OK (check webhook logs for last hour, verify no 401/500 errors). Send deploy summary to Slack `#hingecraft-deployments` and email `deploys@hingecraft-global.ai` with: deploy ID, commit hash, test results, monitoring links, any known issues.

---

## T22 â€” Post-Deploy Checks & QA Signoff

**Paragraph 1 â€” Verification Checklist:**
Produce `verification_signoff.md` with checkboxes for QA to confirm: (a) CTA mapping: for each currency in `payment-currency-map.json`, selecting it updates the CTA URL correctly (manual test: select currency, inspect button `href` or `link` property, verify it matches expected URL), (b) sample payments: complete one test payment for each provider (Stripe card, Stripe ACH, NOWPayments BTC, NOWPayments ETH) using test mode, verify payment is recorded in database, verify confirmation email is sent, (c) webhook delivery: check webhook logs, verify Stripe and NOWPayments webhooks are received and processed (no 401/500 errors), (d) security checks: verify no secrets in code (run `grep -r "sk_live_" .` and `grep -r "x-api-key" .`), verify all secrets in Wix Secrets Manager, (e) accessibility: run Axe-core on Charter page, verify no critical violations, (f) performance: Lighthouse score > 90 for performance, (g) error monitoring: check Sentry for last 24 hours, verify no `TypeError: onReady` or broken link errors.

**Paragraph 2 â€” Test Payment Procedures:**
For each payment provider, provide step-by-step test payment procedures: (a) Stripe Card: use test card `4242 4242 4242 4242`, expiry any future date, CVC any 3 digits, complete checkout, verify `StripePayments` record created with `status: "succeeded"`, (b) Stripe ACH: use test bank account (see Stripe test docs), complete checkout, verify record created, (c) NOWPayments BTC: create invoice, copy wallet address, send test payment (if testnet available) or mark as "paid" manually in NOWPayments dashboard, verify `CryptoPayments` record updated with `status: "confirmed"`. Document expected database states after each test payment.

**Paragraph 3 â€” QA Signoff Process:**
QA must sign off on `verification_signoff.md` by: (a) checking all boxes, (b) adding comments for any issues found, (c) attaching screenshots/videos of test payments, (d) signing with name, date, and approval status. If any critical issues are found (payment failures, broken CTAs, security vulnerabilities), do not sign off. Create a ticket for each issue with: severity (critical/high/medium/low), description, steps to reproduce, expected vs actual behavior, screenshots. Only after all critical issues are resolved can QA sign off. Store signed-off checklist in `test_results/qa_signoff_YYYY-MM-DD.md`.

**Paragraph 4 â€” Production Readiness Gate:**
Before marking as "production ready", verify: (a) all QA checkboxes signed off, (b) all critical issues resolved, (c) monitoring alerts configured (Sentry, Slack, email), (d) rollback procedure tested and documented, (e) runbook created for common issues (`runbooks/charter-onready.md`, `runbooks/payment-failures.md`), (f) documentation updated (`docs/payment-flow.md`, `README.md`), (g) team trained on new system (currency router, payment flows, troubleshooting). Create a "Production Readiness" ticket in project management tool and assign to tech lead for final approval. Only after tech lead approval can the system be marked "production ready".

---

## T23 â€” Security Scan & Compliance

**Paragraph 1 â€” Secrets & Key Hygiene:**
Ensure Stripe secret keys and NOWPayments API keys are stored in Wix Secrets Manager or a vault (never in repository). Scan the repository for secrets: run `grep -r "sk_live_" .`, `grep -r "sk_test_" .`, `grep -r "x-api-key" .`, `grep -r "private.*key" .` (case-insensitive), `grep -r "BEGIN.*PRIVATE KEY" .`. Fail the build (CI step) if any secrets are detected. Use tools like `git-secrets`, `truffleHog`, or `detect-secrets` to scan commits. For any secrets found in history, rotate them immediately and add to `.gitignore`. Document secret locations in `docs/secrets.md` (without exposing actual values): list which secrets are stored where (Wix Secrets Manager keys: `STRIPE_SECRET_TEST`, `STRIPE_SECRET_LIVE`, `NOWPAYMENTS_API_KEY`, etc.).

**Paragraph 2 â€” Server-Side Validation:**
All inbound webhook signatures must be validated server-side (as implemented in T19). Additionally, validate: (a) request origin (check `Origin` or `Referer` header for webhook endpoints, reject if not from Stripe/NOWPayments IPs), (b) request rate limiting (prevent DDoS: max 100 requests per minute per IP, use Wix rate limiting or custom middleware), (c) payload size limits (reject payloads > 1MB), (d) required fields (validate webhook payload schema before processing). Log all validation failures with IP address, timestamp, and reason. Provide code samples for each validation in `docs/webhook_validation.md`.

**Paragraph 3 â€” Payment Failure Handling:**
Provide a resilient flow for payment failures: (a) when payment fails (Stripe returns error, NOWPayments invoice expires, user cancels), capture error code and message, (b) notify user with friendly error message (display on page, don't show raw API errors), (c) create a retry invoice/session with a different payment provider if available (e.g., if Stripe fails, offer NOWPayments crypto option), (d) add a 3-attempt policy with exponential backoff (1st attempt: immediate, 2nd attempt: after 5 minutes, 3rd attempt: after 15 minutes), (e) after 3 failures, mark payment as "failed" and send email to user with manual payment instructions or support contact. Store failure attempts in `payment_audit` table. Document failure handling in `docs/payment_failure_handling.md`.

**Paragraph 4 â€” GDPR & Data Retention:**
Add expiry hooks for payment data: (a) after 7 years (or as per local regulations), purge payment instrument details (card last 4 digits, wallet addresses) from database, (b) on user request (GDPR right to deletion), anonymize payment records (replace user_id with hash, remove PII, keep only audit hashes for reconciliation), (c) provide SQL scripts to anonymize: `scripts/anonymize_payments.sql` (replace `user_id` with `CONCAT('anon_', MD5(user_id))`, remove `email`, `name` fields, keep `amount`, `currency`, `created_at` for analytics). Document retention policy in `docs/data_retention.md` with retention periods for each data type. Add scheduled job to run anonymization monthly.

---

## T24 â€” PII Removal & Anonymization Scripts

**Paragraph 1 â€” Anonymization SQL Scripts:**
Provide SQL scripts to anonymize personal data in payments: (a) `scripts/anonymize_payments.sql`: update `payments` table, set `user_id = CONCAT('anon_', MD5(user_id))`, set `email = NULL`, set `name = NULL`, set `address = NULL`, keep `amount`, `currency`, `created_at`, `gateway`, `status` for analytics, (b) `scripts/anonymize_wallets.sql`: update `wallets` table, set `user_id = CONCAT('anon_', MD5(user_id))`, keep `wallet_address`, `coin`, `currency` (wallet addresses are public, but user association should be removed), (c) `scripts/anonymize_external_payments.sql`: update `external_payments` table, remove PII from `provider_payload` JSON (remove `customer_email`, `billing_details`, etc.), keep only payment IDs and amounts. Test scripts on a copy of production data first. Document in `docs/anonymization.md`.

**Paragraph 2 â€” GDPR Request Handler:**
Create an API endpoint `/_functions/gdpr/deleteUserData` that: (a) accepts `user_id` or `email` as parameter, (b) verifies user identity (require password or email confirmation link), (c) anonymizes all payment records for that user (run anonymization scripts), (d) removes user from `users` table (or marks as deleted), (e) sends confirmation email, (f) logs the deletion request in `gdpr_requests` table with timestamp and user identifier (hashed). Implement rate limiting (max 1 request per user per day) to prevent abuse. Document the endpoint in `docs/gdpr_api.md` with request/response format and authentication requirements.

**Paragraph 3 â€” Retention Policy Enforcement:**
Create a scheduled job (cron or Wix scheduled function) that runs monthly: (a) identify payments older than retention period (7 years default, configurable), (b) for each old payment, check if it's needed for legal/compliance (e.g., tax records, audit trails), (c) if not needed, anonymize it (run anonymization scripts), (d) if needed, keep but remove PII (anonymize user_id, email, name, keep amounts and dates), (e) log anonymization in `data_retention_log` table. Provide configuration file `config/data_retention.json` with retention periods per data type: `payments: 7 years`, `wallets: 7 years`, `external_payments: 7 years`, `audit_logs: 10 years` (for compliance).

**Paragraph 4 â€” Audit Trail Preservation:**
Even after anonymization, preserve audit trails for compliance: (a) keep `payment_audit` records with anonymized `user_id` (hash), (b) keep reconciliation logs with amounts and timestamps (no PII), (c) create summary reports (aggregated by month/year) with total amounts, currency breakdowns, provider breakdowns (no individual user data). Store anonymized audit trails in `audit_archive` table or separate database. Document what is preserved and what is removed in `docs/audit_trail_preservation.md`. Ensure audit trails meet regulatory requirements (PCI DSS, GDPR, local tax laws).

---

## T25 â€” Accessibility & UX Enhancements

**Paragraph 1 â€” Accessibility Requirements:**
Ensure currency control is keyboard navigable: (a) add `tabindex="0"` to currency buttons, (b) handle `Enter` and `Space` key presses to select currency, (c) add `aria-label="currency selector, current {currency}"` to the selector container, (d) add `aria-live="polite"` region that announces currency changes ("Currency changed to Bitcoin"), (e) ensure main CTA is focusable (`tabindex="0"` if it's a `<div>`, or use semantic `<button>` or `<a>`), (f) add focus outline (CSS: `:focus { outline: 2px solid #0066cc; }`). Test with keyboard-only navigation (Tab, Enter, Space). Run Axe-core accessibility scanner on Charter page and fix all critical violations (contrast ratio, missing labels, etc.). Document accessibility features in `docs/accessibility.md`.

**Paragraph 2 â€” UX Microcopy & A/B Testing:**
Design microcopy variations for CTA button: (a) "Pay now", (b) "Complete payment", (c) "Checkout in {currency}", (d) "Continue to {provider}" (e.g., "Continue to Stripe"). Set up A/B test using feature flag or analytics tool (Google Optimize, Optimizely, or custom): randomly assign users to variation A, B, C, or D. Measure conversion rate (clicks on CTA / page views) across 1,000+ impressions per variation. Track events: `cta_clicked` with `variation: "A"` and `currency: "USD"`. After 2 weeks, analyze results: which variation has highest conversion? Implement winning variation as default. Document A/B test setup and results in `docs/ab_test_cta_copy.md`.

**Paragraph 3 â€” Error Message UX:**
Improve error messages for payment failures: (a) replace technical errors ("Failed to create Stripe checkout: 400 Bad Request") with user-friendly messages ("We couldn't process your payment. Please try again or use a different payment method."), (b) provide actionable next steps ("Try using a credit card instead" or "Contact support at payments@hingecraft-global.ai"), (c) add retry button with exponential backoff (show "Retry in 5 seconds" countdown), (d) for crypto payments, if invoice expires, show clear message ("Payment request expired. Please generate a new one.") with button to go back and create new invoice. Test error scenarios and verify messages are clear and helpful. Document error messages in `docs/error_messages.md` with when each message is shown and recommended user actions.

**Paragraph 4 â€” Loading States & Feedback:**
Add loading states for all async operations: (a) when creating crypto invoice, show spinner on CTA button and disable it, display "Creating payment request...", (b) when creating Stripe session, show spinner and "Redirecting to secure checkout...", (c) when polling payment status, show "Waiting for payment confirmation..." with progress indicator, (d) when loading cumulative total, show skeleton loader or "Loading..." text. Use CSS animations or React loading components. Ensure loading states are accessible (screen readers announce "Loading" via `aria-live`). Test with slow network (throttle to 3G in Chrome DevTools) to verify loading states appear correctly. Document loading states in `docs/loading_states.md`.

---

## T26 â€” Analytics Events & BigQuery Integration

**Paragraph 1 â€” Event Schema Design:**
Define analytics events to emit: (a) `currency_selected`: `{ event: "currency_selected", currency: "BTC", source: "charter", timestamp: "2024-01-01T12:00:00Z" }`, (b) `cta_clicked`: `{ event: "cta_clicked", currency: "BTC", url: "https://nowpayments.io/...", source: "charter", timestamp: "..." }`, (c) `payment_started`: `{ event: "payment_started", provider: "stripe", amount: 1.00, currency: "USD", method: "card", timestamp: "..." }`, (d) `payment_succeeded`: `{ event: "payment_succeeded", provider: "stripe", amount: 1.00, currency: "USD", transaction_id: "tx_...", timestamp: "..." }`, (e) `payment_failed`: `{ event: "payment_failed", provider: "stripe", amount: 1.00, currency: "USD", error_code: "card_declined", timestamp: "..." }`. Provide GTM event snippets for each event in `docs/gtm_events.md`.

**Paragraph 2 â€” BigQuery Schema:**
Create BigQuery table schema for event ingestion: table `hingecraft_analytics.events` with columns: `event_id` (STRING, primary key, UUID), `event_name` (STRING: "currency_selected", "cta_clicked", etc.), `user_id` (STRING, hashed for privacy), `session_id` (STRING), `timestamp` (TIMESTAMP), `currency` (STRING, nullable), `provider` (STRING, nullable: "stripe", "nowpayments"), `amount` (FLOAT, nullable), `url` (STRING, nullable), `error_code` (STRING, nullable), `source` (STRING: "charter", "mission_support"), `raw_payload` (JSON: full event data). Partition by `timestamp` (daily partitions) and cluster by `event_name`, `currency`. Provide SQL DDL in `docs/bigquery_schema.sql`.

**Paragraph 3 â€” Event Emission Implementation:**
Implement event emission in frontend: (a) when currency is selected, emit `currency_selected` event (use GTM `dataLayer.push()` or custom analytics function), (b) when CTA is clicked, emit `cta_clicked` event with the URL, (c) when payment is initiated (invoice/session created), emit `payment_started` event, (d) when webhook confirms payment, emit `payment_succeeded` event (backend emits this), (e) when payment fails, emit `payment_failed` event. For backend events (webhook confirmations), use server-side analytics (Google Analytics Measurement Protocol or BigQuery streaming insert). Test events in development: use GTM Preview mode or BigQuery test dataset. Document event emission in `docs/analytics_implementation.md`.

**Paragraph 4 â€” Analytics Dashboard Queries:**
Provide sample BigQuery queries for analytics dashboard: (a) conversion funnel: `SELECT event_name, COUNT(*) as count FROM hingecraft_analytics.events WHERE timestamp >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY) GROUP BY event_name ORDER BY count DESC` (shows event counts), (b) currency breakdown: `SELECT currency, COUNT(*) as selections, SUM(amount) as total_amount FROM hingecraft_analytics.events WHERE event_name = "currency_selected" AND timestamp >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 30 DAY) GROUP BY currency`, (c) payment success rate: `SELECT provider, COUNTIF(event_name = "payment_succeeded") / COUNTIF(event_name = "payment_started") as success_rate FROM hingecraft_analytics.events WHERE event_name IN ("payment_started", "payment_succeeded") GROUP BY provider`. Create dashboard in Google Data Studio or equivalent. Document queries in `docs/analytics_queries.md`.

---

## T27 â€” Documentation & Developer Onboarding

**Paragraph 1 â€” Single Source of Truth:**
Create `docs/payment-flow.md` that describes: (a) payment flow diagram (user selects currency â†’ CTA updates â†’ user clicks â†’ invoice/session created â†’ redirect to provider â†’ webhook confirms â†’ database updated), (b) `payment-currency-map.json` schema and how to add providers (edit JSON, add URL, set priority), (c) environment variables required (`STRIPE_SECRET_TEST`, `NOWPAYMENTS_API_KEY`, etc.) and where they're stored (Wix Secrets Manager), (d) how to add a new currency (add to `payment-currency-map.json`, update `PAYMENT_ROUTES` in HTML, test with Cypress), (e) troubleshooting section (common errors: "CTA not updating" â†’ check currency router logs, "Payment failed" â†’ check webhook logs, "TypeError: onReady" â†’ see runbook). Keep this document up-to-date with every code change.

**Paragraph 2 â€” Runbooks for Common Issues:**
Create `runbooks/charter-onready.md` with emergency steps when `onReady` errors appear: (a) immediate fix: apply guard snippet from T10 (paste into `pa3z2.js`), (b) find the module: search for `charter_page_middleware_web` in repository, check export shape, (c) restore export: if export is missing, add `export async function onReady() { ... }` to source module, (d) verify fix: run smoke test, check console for errors, (e) rollback if needed: use `wix deploy --rollback <id>`. Create `runbooks/payment-failures.md` for payment issues: (a) check webhook logs for errors, (b) verify provider API keys are valid, (c) check database for payment records, (d) test with Stripe CLI or NOWPayments test mode, (e) contact provider support if needed. Document log locations and commands to run.

**Paragraph 3 â€” Developer Onboarding Checklist:**
Provide a checklist for new developers: (a) how to run the local dev server (`npm install`, `npm run dev`, or Wix CLI `wix dev`), (b) where secrets are stored (Wix Secrets Manager, list all secret keys needed), (c) how to run the DB extraction scripts (`node scripts/extract_database_urls_mongo.js` or `psql -f scripts/extract_database_urls.sql`), (d) how to run the tests (`npm test` for unit tests, `npm run cypress:open` for E2E tests), (e) how to add a new payment provider (edit `payment-currency-map.json`, add API integration in `backend/`, update currency router, add Cypress test), (f) code style guide (ESLint config, Prettier config), (g) Git workflow (branch naming, PR template, review process). Store checklist in `docs/developer_onboarding.md`.

**Paragraph 4 â€” API Documentation:**
Create API documentation for all backend endpoints: (a) `/_functions/charter-page-middleware/onReady` (POST, no params, returns `{ success: true, cumulativeTotal: 1000, donationAmount: 5 }`), (b) `/_functions/charter-page-middleware/cryptoButtonClick` (POST, body: `{ amount: 1, coin: "bitcoin" }`, returns `{ success: true, invoiceId: "...", paymentUrl: "...", payAddress: "..." }`), (c) `/_functions/stripe.api/createCheckoutSession` (POST, body: `{ amount: 1, paymentMethod: "card" }`, returns `{ success: true, url: "https://checkout.stripe.com/..." }`), (d) webhook endpoints: `/_functions/webhooks/stripe` (POST, validates signature, processes event), `/_functions/webhooks/nowpayments` (POST, validates HMAC, processes event). Use OpenAPI/Swagger format or Markdown. Include request/response examples, error codes, authentication requirements. Store in `docs/api.md` or `docs/api/openapi.yaml`.

---

## T28 â€” Monitoring & Alerting Setup

**Paragraph 1 â€” Sentry Error Monitoring:**
Create Sentry rule to alert on `TypeError: onReady`: (a) create error filter matching message contains `"onReady"` AND `"is not a function"`, (b) set alert threshold: trigger if > 5 occurrences in 1 hour, (c) send Slack alert to `#hingecraft-payments` with: error message, stack trace (compressed), session ID, user agent, (d) create dashboard widget showing `onReady` error rate over time. Additionally, monitor: (e) payment creation failures (filter: message contains `"Failed to create"` AND `"payment"`), (f) webhook verification failures (filter: status code 401 from webhook endpoints), (g) database connection errors. Document Sentry setup in `docs/monitoring_sentry.md` with screenshots of rules and dashboards.

**Paragraph 2 â€” CloudWatch/Datadog Metrics:**
Create CloudWatch or Datadog metrics for: (a) reconciliation job success rate (custom metric: `payment_reconciliation_success_rate`, value: successful reconciliations / total attempts, alert if < 95%), (b) pending payments count (custom metric: `pending_payments_count`, alert if > 50), (c) average payment processing time (custom metric: `payment_processing_time_ms`, from payment start to webhook confirmation), (d) currency selection distribution (counter metric: `currency_selected{currency="BTC"}`, track each currency selection). Create dashboards showing: payment volume over time, success rate by provider, top currencies selected, error rate trends. Set up alerts: if reconciliation success rate < 95% for 1 hour, send email to `payments@hingecraft-global.ai`; if pending payments > 50, send Slack alert.

**Paragraph 3 â€” Slack Integration:**
Configure Slack webhook for deploy alerts: (a) create Slack app with incoming webhook, (b) add webhook URL to Wix Secrets (`SLACK_WEBHOOK_URL`), (c) send deploy summary to `#hingecraft-deployments` channel with: deploy ID, commit hash, test results (pass/fail counts), monitoring links (Sentry, CloudWatch), any known issues, (d) send critical error alerts to `#hingecraft-payments` channel (payment failures, webhook errors, reconciliation failures). Format messages with Slack blocks (sections, dividers, buttons for links). Test webhook with `curl -X POST $SLACK_WEBHOOK_URL -d '{"text":"Test message"}'`. Document Slack setup in `docs/monitoring_slack.md`.

**Paragraph 4 â€” Email Alerts:**
Configure email alerts for critical issues: (a) payment reconciliation failures (send to `payments@hingecraft-global.ai` with list of failed reconciliations and recommended actions), (b) security alerts (secret keys detected in code, send to `security@hingecraft-global.ai`), (c) weekly summary (send to `team@hingecraft-global.ai` with: total payments processed, success rate, top currencies, any issues). Use email service (SendGrid, AWS SES, or Wix Email API). Template emails in `docs/email_templates/` with HTML and plain text versions. Document email setup in `docs/monitoring_email.md`.

---

## T29 â€” Automation & Weekly Maintenance Jobs

**Paragraph 1 â€” Weekly Resource Check:**
Schedule weekly crawl job (GitHub Action or cron): (a) run `scripts/crawl_all_resources.js` every Monday at 2 AM UTC, (b) compare results to previous week's report (stored in `test_results/resource_report_last_week.json`), (c) identify new broken links (URLs that were working last week but are broken now), (d) email `links@hingecraft-global.ai` with summary: total URLs checked, new broken links (list with status codes), critical failures (payment provider URLs that are broken), SSL expiring soon (< 30 days). Archive weekly reports in `test_results/resource_reports/YYYY-MM-DD_resource_report.json`. Create GitHub Action workflow `.github/workflows/weekly_resource_check.yml` or cron script `scripts/weekly_resource_check.sh`.

**Paragraph 2 â€” Weekly Reconciliation Report:**
Create weekly reconciliation CSV export: (a) run reconciliation job (from T20) to update all pending payments, (b) generate CSV with columns: `payment_id`, `provider`, `amount`, `currency`, `status`, `reconciled_at`, `mismatch_flag`, (c) email CSV to `reconciliation@hingecraft-global.ai` every Monday at 9 AM UTC, (d) create summary email with: total payments reconciled, mismatch count, success rate, any action items (payments that need manual review). Store CSV in `test_results/reconciliation_reports/YYYY-MM-DD_reconciliation.csv`. Automate with scheduled function or GitHub Action.

**Paragraph 3 â€” Automated Ticket Creation:**
For broken payment URLs or reconciliation mismatches, automatically create tickets in project management tool (Jira, Linear, GitHub Issues): (a) if payment URL is broken (from resource check), create ticket with title "Broken Payment URL: {currency} - {url}", assign to payments team, add label "payment-url", (b) if reconciliation mismatch detected (from T20), create ticket with title "Payment Reconciliation Mismatch: {payment_id}", assign to payments team, add label "reconciliation", include details: local status vs provider status, amount difference, recommended action. Use project management API (Jira API, Linear API, GitHub Issues API) to create tickets. Document ticket creation in `docs/automation_tickets.md`.

**Paragraph 4 â€” Monthly Anonymization Job:**
Schedule monthly anonymization job (from T24): (a) run anonymization scripts on payments older than retention period, (b) log anonymization in `data_retention_log` table, (c) send summary email to `compliance@hingecraft-global.ai` with: number of records anonymized, date range anonymized, any errors encountered. Run on first Monday of each month at 3 AM UTC. Test on staging database first. Document in `docs/automation_anonymization.md`.

---

## T30 â€” Final Handover Package & Release

**Paragraph 1 â€” Artifact Packaging:**
Package all final artifacts into `hingecraft_payment_release_v1.zip`: (a) code files: `charter-page-wix-ready.html` (fixed version), `currencyRouter.js`, `payment-currency-map.json`, all backend modules (`.jsw`, `.web.js` files), (b) scripts: `extract_database_urls.sql`, `extract_database_urls_mongo.js`, `crawl_all_resources.js`, `stripe_test_mode_setup.js`, `nowpayments_invoice_creator.js`, (c) tests: `jest/currencyRouter.spec.js`, `cypress/integration/charter_currency_spec.js`, `test/smoke_check_charter.js`, (d) documentation: `docs/payment-flow.md`, `runbooks/charter-onready.md`, `docs/developer_onboarding.md`, `docs/api.md`, all T10-T30 prompt files, (e) database exports: sample CSVs from T11 (with PII redacted), `normalized_payments.csv`, `payment-currency-map.json`, (f) configuration: `.env.example` (with placeholder values), `package.json`, deployment configs.

**Paragraph 2 â€” Release Notes:**
Create `RELEASE_NOTES_v1.md` with: (a) summary of changes (currency routing system, dynamic CTA updates, database integration, webhook verification), (b) new features (currency selector updates CTA URL, payment-currency-map.json for centralized routing, Stripe test mode support, NOWPayments invoice creation), (c) bug fixes (fixed `TypeError: onReady`, fixed CTA not updating on currency selection, fixed Stripe checkout creation), (d) breaking changes (none, backward compatible), (e) migration guide (if updating from old system, steps to migrate), (f) known issues (list any known limitations or bugs), (g) contributors (list developers who worked on this release). Version the release (semantic versioning: v1.0.0).

**Paragraph 3 â€” Delivery & Verification:**
Deliver the zip file via secure channel (encrypted email, secure file share, or private GitHub release): (a) upload to secure location, (b) share download link with team (use password-protected link or require authentication), (c) verify all files are present (run checksum on zip file, provide MD5/SHA256 hash), (d) provide extraction instructions (unzip, verify file structure, check file permissions). After delivery, schedule a handover meeting: (a) walk through the codebase structure, (b) demonstrate currency routing in action (live demo), (c) explain database schema and relationships, (d) review monitoring and alerting setup, (e) Q&A session. Record the meeting and store recording link in `docs/handover_meeting_recording.md`.

**Paragraph 4 â€” Post-Release Support:**
Establish post-release support process: (a) create support channel (Slack `#hingecraft-payments-support` or email `payments-support@hingecraft-global.ai`), (b) define SLA (respond to critical issues within 2 hours, non-critical within 24 hours), (c) assign on-call rotation (one developer on-call per week, escalation path defined), (d) create runbook for common support requests (payment not processing, CTA not updating, webhook not received). Monitor support channel for first 2 weeks after release, gather feedback, and create follow-up tickets for improvements. Schedule retrospective meeting after 2 weeks to discuss what went well, what could be improved, and action items for next release.

---

## Ongoing Multi-Prompt Sequence

Execute these prompts in order. Each step writes artifacts used by the next:

1. **run_inventory_and_guard** â€” Run T10 inventory script & apply guard
2. **export_hingecraft_payments** â€” Run DB export (SQL/Mongo from T11)
3. **normalize_and_map** â€” Create normalized_payments.csv (T11)
4. **build_currency_map** â€” Build payment-currency-map.json (T12)
5. **patch_frontend_router** â€” Add currencyRouter.js to Charter page (T12)
6. **nowpayments_invoices** â€” Create invoices for crypto currencies (T14)
7. **stripe_checkout_setup** â€” Create Checkout sessions for fiat (T15)
8. **cypress_e2e_run** â€” Run Cypress tests on test site (T17)
9. **reconcile_and_audit** â€” Call provider APIs to record URLs (T15, T20)
10. **deploy_canary_and_monitor** â€” Canary deploy and smoke checks (T21)

---

## Raw Components Checklist

- [ ] `pa3z2.js` â€” add guard snippet (T10)
- [ ] `masterPage.js` â€” inspect for module imports (T10)
- [ ] `public/currencyRouter.js` â€” new module (T12)
- [ ] `public/payment-currency-map.json` â€” new mapping file (T12)
- [ ] SQL exports: `/tmp/hingecraft_payments.csv`, `/tmp/hingecraft_wallets.csv`, `/tmp/hingecraft_external_payments.csv` (T11)
- [ ] Scripts: `createNowInvoice.js`, `stripe_reconcile.js`, `crawl_resources.js` (T14, T15, T18)
- [ ] Tests: `test/smoke_check_charter.js`, `cypress/charter_currency_spec.js`, `jest/currencyRouter.spec.js` (T10, T12, T17)
- [ ] CI: workflow step for `cypress:run` & `smoke_check` (T17, T21)
- [ ] DB: `payment_audit` table (create SQL) (T20)
- [ ] Secrets: `STRIPE_SECRET_TEST`, `STRIPE_SECRET_LIVE`, `NOWPAYMENTS_API_KEY` stored in Wix Secrets (T15, T23)
- [ ] Monitoring: Sentry rule for `TypeError: onReady`, Slack webhook for deploy alerts (T28)
- [ ] Docs: `docs/payment-flow.md`, `runbooks/charter-onready.md`, `verification_signoff.md` (T27, T22)
- [ ] Cron: `resources_check.sh` weekly run (T18, T29)
- [ ] Accessibility: aria-live region, ARIA labels for currency select, keyboard test scripts (T25)
- [ ] Analytics events: `currency_selected`, `cta_clicked`, `payment_started`, `payment_succeeded`, `payment_failed` (T26)
- [ ] Rollback scripts: `rollback.sh` using Wix/hosting CLI (T21)
- [ ] Example test card numbers list (Stripe test cards) â€” put in `docs/test_vectors.md` (T15)
- [ ] Example test vectors for URL validation (10+ positive, 10+ negative) (T12)
- [ ] Example error handling policy (3 attempts with backoff) (T23)
- [ ] BigQuery schema for analytics events (T26)

---

**End of T10-T30 Prompts**
