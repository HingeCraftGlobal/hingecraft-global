/**
 * GPT Form Configuration - Wix Velo Backend Module
 * Automated GPT trigger to configure forms based on prompts
 * 
 * Functions:
 * - configureFormFromPrompt(prompt) ‚Üí Use GPT to configure form based on prompt
 * - updateFormConfiguration(formId, config) ‚Üí Update form configuration
 * - getFormConfiguration(formId) ‚Üí Get current form configuration
 * 
 * IMPORTANT: This is a .jsw file - HTTP-accessible via /_functions/gpt-form-config/[function-name]
 * Permissions: Anyone (for public access, but should be restricted in production)
 */

import wixData from 'wix-data';
import { secrets } from 'wix-secrets-backend';
import { fetch } from 'wix-fetch';

/**
 * Configure form from GPT prompt
 * Uses GPT to analyze prompt and generate form configuration
 * @public
 * @param {string} prompt - Configuration prompt
 * @param {string} formId - Form identifier (e.g., "mission-support-form")
 */
export async function configureFormFromPrompt(prompt, formId = 'mission-support-form') {
    try {
        console.log('ü§ñ GPT Form Configuration triggered:', { prompt, formId });
        
        // Get OpenAI API key
        let openaiKey;
        try {
            openaiKey = await secrets.getSecret('OPENAI_API_KEY');
        } catch (e) {
            throw new Error('OpenAI API key not found in secrets');
        }
        
        // Generate form configuration using GPT
        const formConfig = await generateFormConfigWithGPT(prompt, formId, openaiKey);
        
        // Save configuration to database
        try {
            await saveFormConfiguration(formId, formConfig, prompt);
        } catch (dbError) {
            console.warn('‚ö†Ô∏è Error saving form configuration (non-blocking):', dbError);
        }
        
        return {
            success: true,
            formId: formId,
            configuration: formConfig,
            message: 'Form configured successfully'
        };
        
    } catch (error) {
        console.error('‚ùå GPT form configuration error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Generate form configuration using GPT
 * @private
 * @param {string} prompt - Configuration prompt
 * @param {string} formId - Form identifier
 * @param {string} openaiKey - OpenAI API key
 */
async function generateFormConfigWithGPT(prompt, formId, openaiKey) {
    const systemPrompt = `You are an expert at configuring web forms for donation and mission support systems. 
Analyze the user's prompt and generate a complete form configuration in JSON format.

The form is for HingeCraft Global Mission Support, which handles:
- Donation amounts ($1 to $25,000)
- Payment methods (card, crypto)
- Donor information (name, email, address)
- Mission support names (optional)

Generate configuration that includes:
1. Field configurations (required/optional, validation rules)
2. Payment options (micro payments, custom amounts)
3. Form layout and styling suggestions
4. Validation rules
5. Error messages
6. Success messages
7. Integration points

Respond ONLY with valid JSON in this format:
{
  "fields": {
    "firstName": { "required": true, "validation": "...", "label": "...", "placeholder": "..." },
    "lastName": { "required": true, "validation": "...", "label": "...", "placeholder": "..." },
    "email": { "required": true, "validation": "...", "label": "...", "placeholder": "..." },
    "address": { "required": true, "validation": "...", "label": "...", "placeholder": "..." },
    "missionSupportName": { "required": false, "validation": "...", "label": "...", "placeholder": "..." },
    "amount": { "required": true, "validation": "...", "label": "...", "min": 1, "max": 25000 }
  },
  "paymentOptions": {
    "microPayments": [1, 2, 5],
    "allowCustomAmount": true,
    "paymentMethods": ["card", "crypto"]
  },
  "validation": {
    "rules": { ... },
    "errorMessages": { ... }
  },
  "messages": {
    "success": "...",
    "error": "...",
    "validation": { ... }
  },
  "styling": {
    "suggestions": "..."
  }
}`;

    const userPrompt = `Configure the ${formId} form based on this prompt:

${prompt}

Ensure the configuration:
- Handles all required fields properly
- Includes proper validation
- Supports all payment methods
- Has clear error messages
- Follows best practices for donation forms
- Is optimized for conversion`;

    try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${openaiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model: 'gpt-4-turbo-preview',
                messages: [
                    {
                        role: 'system',
                        content: systemPrompt
                    },
                    {
                        role: 'user',
                        content: userPrompt
                    }
                ],
                temperature: 0.7,
                max_tokens: 2000
            })
        });
        
        if (!response.ok) {
            throw new Error(`OpenAI API error: ${response.status}`);
        }
        
        const data = await response.json();
        const content = data.choices[0].message.content;
        
        // Parse JSON from response
        const config = JSON.parse(content);
        
        return config;
        
    } catch (error) {
        console.error('‚ùå GPT form configuration error:', error);
        // Return default configuration
        return getDefaultFormConfiguration();
    }
}

/**
 * Get default form configuration
 * @private
 */
function getDefaultFormConfiguration() {
    return {
        fields: {
            firstName: {
                required: true,
                validation: '/^[a-zA-Z\\-\\s]{1,50}$/',
                label: 'First Name',
                placeholder: 'Enter your first name'
            },
            lastName: {
                required: true,
                validation: '/^[a-zA-Z\\-\\s]{1,50}$/',
                label: 'Last Name',
                placeholder: 'Enter your last name'
            },
            email: {
                required: true,
                validation: '/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/',
                label: 'Email Address',
                placeholder: 'your.email@example.com'
            },
            address: {
                required: true,
                validation: '/^[a-zA-Z0-9\\s\\-\\.,#]{1,200}$/',
                label: 'Address',
                placeholder: 'Enter your address'
            },
            missionSupportName: {
                required: false,
                validation: '/^[a-zA-Z0-9\\s\\-\\.,]{0,200}$/',
                label: 'Mission Support Name (Optional)',
                placeholder: 'Name of mission or initiative'
            },
            amount: {
                required: true,
                validation: '/^\\d{1,5}(\\.\\d{1,2})?$/',
                label: 'Donation Amount',
                min: 1.00,
                max: 25000.00
            }
        },
        paymentOptions: {
            microPayments: [1, 2, 5],
            allowCustomAmount: true,
            paymentMethods: ['card', 'crypto']
        },
        validation: {
            rules: {
                firstName: 'First name must be 1-50 characters, letters, hyphens, and spaces only',
                lastName: 'Last name must be 1-50 characters, letters, hyphens, and spaces only',
                email: 'Please enter a valid email address',
                address: 'Address must be 1-200 characters',
                amount: 'Amount must be between $1.00 and $25,000.00'
            }
        },
        messages: {
            success: 'Thank you for your contribution!',
            error: 'Please check the form and try again.',
            validation: {
                required: 'This field is required',
                invalid: 'Please enter a valid value'
            }
        },
        styling: {
            suggestions: 'Use clean, modern design with clear call-to-action buttons'
        }
    };
}

/**
 * Save form configuration to database
 * @private
 * @param {string} formId - Form identifier
 * @param {Object} config - Form configuration
 * @param {string} prompt - Original prompt
 */
async function saveFormConfiguration(formId, config, prompt) {
    try {
        const configId = 'config_' + formId + '_' + Date.now().toString(36);
        const timestamp = new Date();
        
        const configRecord = {
            _id: configId,
            formId: formId,
            configuration: config,
            prompt: prompt,
            version: '1.0',
            isActive: true,
            created_at: timestamp,
            updated_at: timestamp,
            metadata: {
                generatedBy: 'gpt-4-turbo-preview',
                generatedAt: timestamp.toISOString()
            }
        };
        
        // Save to FormConfigurations collection
        await wixData.save('FormConfigurations', configRecord);
        console.log('‚úÖ Form configuration saved:', configId);
        
        return {
            success: true,
            configId: configId
        };
        
    } catch (error) {
        console.error('‚ùå Error saving form configuration:', error);
        throw error;
    }
}

/**
 * Update form configuration
 * @public
 * @param {string} formId - Form identifier
 * @param {Object} config - Updated configuration
 */
export async function updateFormConfiguration(formId, config) {
    try {
        // Get current configuration
        const currentConfig = await wixData.query('FormConfigurations')
            .eq('formId', formId)
            .eq('isActive', true)
            .descending('created_at')
            .find();
        
        // Deactivate old configuration
        if (currentConfig.items.length > 0) {
            for (const oldConfig of currentConfig.items) {
                await wixData.update('FormConfigurations', {
                    ...oldConfig,
                    isActive: false,
                    updated_at: new Date()
                });
            }
        }
        
        // Save new configuration
        const configId = 'config_' + formId + '_' + Date.now().toString(36);
        const timestamp = new Date();
        
        const configRecord = {
            _id: configId,
            formId: formId,
            configuration: config,
            version: (currentConfig.items.length > 0 ? parseFloat(currentConfig.items[0].version) + 0.1 : 1.0).toFixed(1),
            isActive: true,
            created_at: timestamp,
            updated_at: timestamp,
            metadata: {
                updatedBy: 'manual',
                updatedAt: timestamp.toISOString()
            }
        };
        
        await wixData.save('FormConfigurations', configRecord);
        console.log('‚úÖ Form configuration updated:', configId);
        
        return {
            success: true,
            configId: configId,
            version: configRecord.version
        };
        
    } catch (error) {
        console.error('‚ùå Error updating form configuration:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Get current form configuration
 * @public
 * @param {string} formId - Form identifier
 */
export async function getFormConfiguration(formId) {
    try {
        const config = await wixData.query('FormConfigurations')
            .eq('formId', formId)
            .eq('isActive', true)
            .descending('created_at')
            .find();
        
        if (config.items.length === 0) {
            // Return default configuration
            return {
                success: true,
                formId: formId,
                configuration: getDefaultFormConfiguration(),
                isDefault: true
            };
        }
        
        return {
            success: true,
            formId: formId,
            configuration: config.items[0].configuration,
            version: config.items[0].version,
            isDefault: false
        };
        
    } catch (error) {
        console.error('‚ùå Error getting form configuration:', error);
        return {
            success: false,
            error: error.message
        };
    }
}
