/**
 * Charter Page Velo Middleware
 * T10 Implementation: Full middleware binding + dynamic totals + 2-page sync
 * 
 * Functions:
 * - onReady() ‚Üí check dataset ‚Üí update totals
 * - cryptoButtonClick(amount, coin) ‚Üí call NowPayments handler
 * - fiatButtonClick(preset) ‚Üí call Stripe dev key handler
 * - afterPaymentWebhook(payload) ‚Üí update DB + totals
 * - redirectBackToCharter() ‚Üí route with state
 * - getCumulativeTotal() ‚Üí calculate total from database
 * 
 * IMPORTANT: This is a .jsw file - HTTP-accessible via /_functions/charter-page-middleware/[function-name]
 * Permissions: Anyone (for public access)
 */

import wixData from 'wix-data';
import { createNowPaymentsInvoice } from 'backend/nowpayments.api';
import { createCheckoutSession } from 'backend/stripe.api';
import { getLatestDonation, saveDonation } from 'backend/hingecraft.api.web';

/**
 * Initialize charter page on ready
 * Checks dataset and updates totals dynamically
 * FIXED: No longer uses deprecated import pattern - uses HTTP endpoint calls
 * @public
 */
export async function onReady() {
    try {
        console.log('üöÄ Charter Page Middleware: onReady()');
        
        // Get cumulative total from database
        const totalResult = await getCumulativeTotal();
        
        // Check for prefill token in URL
        let donationAmount = null;
        let prefillId = null;
        
        try {
            if (typeof wixLocation !== 'undefined' && wixLocation.query) {
                prefillId = wixLocation.query.prefill;
                const urlAmount = wixLocation.query.donationAmount || wixLocation.query.amount;
                if (urlAmount) {
                    donationAmount = parseFloat(urlAmount);
                }
            }
        } catch (e) {
            console.warn('Could not read URL params:', e);
        }
        
        // If prefill ID exists, get prefill data
        if (prefillId) {
            try {
                // Import mission support middleware to get prefill
                const { getPrefill } = await import('backend/mission-support-middleware');
                const prefillResult = await getPrefill(prefillId);
                if (prefillResult.success) {
                    donationAmount = prefillResult.amount;
                    console.log('‚úÖ Prefill loaded:', donationAmount);
                }
            } catch (e) {
                console.warn('Could not load prefill:', e);
            }
        }
        
        // Check session storage as fallback
        if (!donationAmount) {
            donationAmount = await getDonationAmountFromStorage();
        }
        
        // Setup database change listeners
        setupDatabaseListeners();
        
        return {
            success: true,
            cumulativeTotal: totalResult.total,
            donationAmount: donationAmount,
            prefillId: prefillId
        };
    } catch (error) {
        console.error('‚ùå Charter Page onReady error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Handle crypto button click
 * Creates NOWPayments invoice for selected crypto
 * @public
 * @param {Object|number} requestData - Donation amount and coin, or just amount (for backward compatibility)
 * @param {number} requestData.amount - Donation amount
 * @param {string} requestData.coin - Cryptocurrency (solana, stellar, bitcoin, ethereum)
 */
export async function cryptoButtonClick(requestData) {
    try {
        // Support both object and positional parameters for backward compatibility
        let amount, coin;
        if (typeof requestData === 'object' && requestData !== null) {
            amount = requestData.amount;
            coin = requestData.coin;
        } else {
            // Legacy: positional parameters
            amount = requestData;
            coin = arguments[1];
        }
        
        console.log('üí∞ Crypto button clicked:', { amount, coin });
        
        // Validate amount
        const validatedAmount = validateAmount(amount);
        if (!validatedAmount) {
            throw new Error('Invalid amount');
        }
        
        // Validate coin
        const validCoins = ['solana', 'stellar', 'bitcoin', 'ethereum', 'SOL', 'XLM', 'BTC', 'ETH'];
        const normalizedCoin = coin.toLowerCase();
        if (!validCoins.includes(normalizedCoin)) {
            throw new Error('Invalid cryptocurrency');
        }
        
        // Map coin to NOWPayments format
        const payCurrencyMap = {
            'solana': 'SOL',
            'stellar': 'XLM',
            'bitcoin': 'BTC',
            'ethereum': 'ETH',
            'sol': 'SOL',
            'xlm': 'XLM',
            'btc': 'BTC',
            'eth': 'ETH'
        };
        
        const payCurrency = payCurrencyMap[normalizedCoin] || normalizedCoin.toUpperCase();
        
        // Generate intent ID
        const intentId = 'hc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        // Get session data if available
        let email = '';
        let firstName = '';
        let lastName = '';
        
        try {
            if (typeof wixStorage !== 'undefined' && wixStorage.session) {
                const donationData = wixStorage.session.getItem('hingecraft_donation');
                if (donationData) {
                    const data = JSON.parse(donationData);
                    email = data.email || '';
                    firstName = data.firstName || '';
                    lastName = data.lastName || '';
                }
            }
        } catch (e) {
            console.warn('Could not get session data:', e);
        }
        
        // Create NOWPayments invoice
        const invoiceResult = await createNowPaymentsInvoice({
            intentId: intentId,
            amount: validatedAmount,
            payCurrency: payCurrency,
            email: email,
            sessionId: await getSessionId(),
            firstName: firstName,
            lastName: lastName
        });
        
        if (!invoiceResult.success) {
            throw new Error(invoiceResult.error || 'Failed to create crypto invoice');
        }
        
        // Store invoice data in session
        await storeCryptoInvoiceData(invoiceResult);
        
        // Store donation amount
        await storeDonationAmount(validatedAmount, 'crypto', coin);
        
        return {
            success: true,
            invoiceId: invoiceResult.invoiceId,
            paymentUrl: invoiceResult.paymentUrl,
            payAddress: invoiceResult.payAddress,
            payAmountCrypto: invoiceResult.payAmountCrypto,
            payCurrency: invoiceResult.payCurrency,
            intentId: intentId
        };
    } catch (error) {
        console.error('‚ùå Crypto button click error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Handle fiat button click (Stripe)
 * Creates Stripe checkout session for any amount
 * @public
 * @param {Object|number} requestData - Payment amount and method, or just amount (for backward compatibility)
 * @param {number} requestData.amount - Payment amount (any valid amount between $1.00 and $25,000.00)
 * @param {string} requestData.paymentMethod - Payment method: "card" or "ACH" (optional, defaults to "card")
 */
export async function fiatButtonClick(requestData) {
    try {
        // Support both object and positional parameters for backward compatibility
        let amount, paymentMethod;
        if (typeof requestData === 'object' && requestData !== null) {
            amount = requestData.amount;
            paymentMethod = requestData.paymentMethod || 'card';
        } else {
            // Legacy: positional parameters
            amount = requestData;
            paymentMethod = arguments[1] || 'card';
        }
        
        console.log('üí≥ Fiat button clicked:', { amount, paymentMethod });
        
        // Validate amount
        const validatedAmount = parseFloat(amount);
        if (isNaN(validatedAmount) || validatedAmount < 1.00 || validatedAmount > 25000.00) {
            throw new Error(`Invalid amount: ${amount} (must be between $1.00 and $25,000.00)`);
        }
        
        const baseUrl = await getBaseUrl();
        
        // Create Stripe checkout session
        const sessionResult = await createCheckoutSession({
            amount: validatedAmount,
            paymentMethod: paymentMethod,
            successUrl: `${baseUrl}/payment-success?amount=${validatedAmount}&method=${paymentMethod}`,
            cancelUrl: `${baseUrl}/charter?canceled=true&amount=${validatedAmount}`,
            donationId: null,
            email: null,
            baseUrl: baseUrl
        });
        
        if (!sessionResult.success) {
            throw new Error(sessionResult.error || 'Failed to create Stripe session');
        }
        
        // Store donation amount
        await storeDonationAmount(validatedAmount, paymentMethod, null);
        
        return {
            success: true,
            sessionId: sessionResult.sessionId,
            url: sessionResult.url,
            amount: validatedAmount,
            paymentMethod: paymentMethod
        };
    } catch (error) {
        console.error('‚ùå Fiat button click error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Handle payment webhook
 * Updates database and totals after payment
 * @public
 * @param {Object} payload - Webhook payload
 */
export async function afterPaymentWebhook(payload) {
    try {
        console.log('üì• Payment webhook received:', payload);
        
        const { paymentMethod, amount, transactionId, status, invoiceId } = payload;
        
        // Save donation to database
        const donationResult = await saveDonation({
            amount: amount,
            currency: 'USD',
            isOtherAmount: false,
            source: 'charter_page',
            paymentStatus: status || 'completed',
            paymentMethod: paymentMethod,
            transactionId: transactionId,
            email: payload.email || null,
            name: payload.name || null,
            metadata: {
                invoiceId: invoiceId,
                webhookPayload: payload
            }
        });
        
        // Update cumulative total
        const totalResult = await getCumulativeTotal();
        
        // Trigger contributions update
        await updateContributionsDisplay(totalResult.total);
        
        return {
            success: true,
            donationId: donationResult.donationId,
            cumulativeTotal: totalResult.total
        };
    } catch (error) {
        console.error('‚ùå Payment webhook error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Redirect back to charter page with state
 * @public
 * @param {number} donationAmount - Donation amount
 * @param {string} paymentMethod - Payment method
 */
export async function redirectBackToCharter(donationAmount, paymentMethod) {
    try {
        const baseUrl = await getBaseUrl();
        const redirectUrl = `${baseUrl}/charter?donationAmount=${donationAmount}&paymentMethod=${paymentMethod}&fromMissionSupport=true`;
        
        return {
            success: true,
            redirectUrl: redirectUrl
        };
    } catch (error) {
        console.error('‚ùå Redirect error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Get cumulative total from database
 * Sums all completed donations (crypto + fiat)
 * @public
 */
export async function getCumulativeTotal() {
    try {
        // Get all completed donations
        const donations = await wixData.query('Donations')
            .eq('payment_status', 'completed')
            .or(wixData.query('Donations').eq('payment_status', 'confirmed'))
            .find();
        
        // Get all confirmed crypto payments
        const cryptoPayments = await wixData.query('CryptoPayments')
            .eq('status', 'confirmed')
            .find();
        
        // Calculate totals
        let fiatTotal = 0;
        donations.items.forEach(donation => {
            if (donation.amount) {
                fiatTotal += parseFloat(donation.amount);
            }
        });
        
        let cryptoTotal = 0;
        cryptoPayments.items.forEach(payment => {
            if (payment.price_amount) {
                cryptoTotal += parseFloat(payment.price_amount);
            }
        });
        
        const total = fiatTotal + cryptoTotal;
        
        console.log('üí∞ Cumulative total calculated:', {
            fiatTotal,
            cryptoTotal,
            total
        });
        
        return {
            success: true,
            total: total,
            fiatTotal: fiatTotal,
            cryptoTotal: cryptoTotal,
            fiatCount: donations.items.length,
            cryptoCount: cryptoPayments.items.length
        };
    } catch (error) {
        console.error('‚ùå Error calculating cumulative total:', error);
        return {
            success: false,
            total: 0,
            error: error.message
        };
    }
}

/**
 * Update contributions display
 */
async function updateContributionsDisplay(total) {
    try {
        // This will be called from frontend to update the display
        // Store in session for frontend to pick up
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_cumulative_total', JSON.stringify({
                total: total,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error updating contributions display:', error);
    }
}

/**
 * Get donation amount from storage
 */
async function getDonationAmountFromStorage() {
    try {
        // Check URL parameters (handled by frontend)
        // Check session storage
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            const stored = wixStorage.session.getItem('hingecraft_donation');
            if (stored) {
                const data = JSON.parse(stored);
                if (data.amount) {
                    return parseFloat(data.amount);
                }
            }
        }
        return null;
    } catch (error) {
        console.error('Error getting donation amount:', error);
        return null;
    }
}

/**
 * Display donation amount
 */
async function displayDonationAmount(amount) {
    try {
        // Store for frontend to display
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_donation_display', JSON.stringify({
                amount: amount,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error storing donation display:', error);
    }
}

/**
 * Setup database change listeners
 */
function setupDatabaseListeners() {
    try {
        // Listen for changes to Donations collection
        wixData.onChange('Donations', async (changedItem) => {
            console.log('üìä Donations collection changed:', changedItem);
            
            // Recalculate total
            const totalResult = await getCumulativeTotal();
            await updateContributionsDisplay(totalResult.total);
        });
        
        // Listen for changes to CryptoPayments collection
        wixData.onChange('CryptoPayments', async (changedItem) => {
            console.log('üìä CryptoPayments collection changed:', changedItem);
            
            // Recalculate total
            const totalResult = await getCumulativeTotal();
            await updateContributionsDisplay(totalResult.total);
        });
    } catch (error) {
        console.error('Error setting up database listeners:', error);
    }
}

/**
 * Store crypto invoice data
 */
async function storeCryptoInvoiceData(invoiceData) {
    try {
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_crypto_invoice', JSON.stringify({
                invoiceId: invoiceData.invoiceId,
                paymentUrl: invoiceData.paymentUrl,
                payAddress: invoiceData.payAddress,
                payAmountCrypto: invoiceData.payAmountCrypto,
                payCurrency: invoiceData.payCurrency,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error storing crypto invoice:', error);
    }
}

/**
 * Store donation amount
 */
async function storeDonationAmount(amount, method, coin) {
    try {
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_donation', JSON.stringify({
                amount: amount,
                paymentMethod: method,
                coin: coin,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error storing donation amount:', error);
    }
}

/**
 * Get session ID
 */
async function getSessionId() {
    try {
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            let sessionId = wixStorage.session.getItem('hingecraft_session_id');
            if (!sessionId) {
                sessionId = 'hc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                wixStorage.session.setItem('hingecraft_session_id', sessionId);
            }
            return sessionId;
        }
        return 'hc_' + Date.now();
    } catch (error) {
        return 'hc_' + Date.now();
    }
}

/**
 * Get base URL
 */
async function getBaseUrl() {
    try {
        const { secrets } = await import('wix-secrets-backend');
        const baseUrl = await secrets.getSecret('BASE_URL');
        return baseUrl || 'https://www.hingecraft-global.ai';
    } catch (error) {
        return 'https://www.hingecraft-global.ai';
    }
}

/**
 * Validate amount
 */
function validateAmount(amount) {
    const n = Number(amount);
    if (!isFinite(n)) return null;
    
    const regex = /^\d{1,5}(\.\d{1,2})?$/;
    const rounded = Math.round(n * 100) / 100;
    
    if (!regex.test(String(rounded))) return null;
    if (rounded < 1.00 || rounded > 25000.00) return null;
    
    return rounded;
}
