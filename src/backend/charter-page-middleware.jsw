/**
 * Charter Page Velo Middleware
 * T10 Implementation: Full middleware binding + dynamic totals + 2-page sync
 * 
 * Functions:
 * - onReady() ‚Üí check dataset ‚Üí update totals
 * - cryptoButtonClick(amount, coin) ‚Üí call NowPayments handler
 * - fiatButtonClick(preset) ‚Üí call Stripe dev key handler
 * - afterPaymentWebhook(payload) ‚Üí update DB + totals
 * - redirectBackToCharter() ‚Üí route with state
 * - getCumulativeTotal() ‚Üí calculate total from database
 */

import wixData from 'wix-data';
import { createNowPaymentsInvoice } from 'backend/nowpayments.api';
import { createCheckoutSession } from 'backend/stripe.api';
import { getLatestDonation, saveDonation } from 'backend/hingecraft.api.web';

/**
 * Initialize charter page on ready
 * Checks dataset and updates totals dynamically
 */
export async function onReady() {
    try {
        console.log('üöÄ Charter Page Middleware: onReady()');
        
        // Get cumulative total from database
        const totalResult = await getCumulativeTotal();
        
        // Update contributions section
        await updateContributionsDisplay(totalResult.total);
        
        // Check for donation amount in URL or storage
        const donationAmount = await getDonationAmountFromStorage();
        
        if (donationAmount && donationAmount > 0) {
            // Display donation amount
            await displayDonationAmount(donationAmount);
            
            // Update contributions with new amount
            await updateContributionsDisplay(totalResult.total + donationAmount);
        }
        
        // Setup database change listeners
        setupDatabaseListeners();
        
        return {
            success: true,
            cumulativeTotal: totalResult.total,
            donationAmount: donationAmount
        };
    } catch (error) {
        console.error('‚ùå Charter Page onReady error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Handle crypto button click
 * Creates NOWPayments invoice for selected crypto
 * 
 * CRITICAL: Uses intentId from ContributionIntent as order_id (custom invoice ID)
 * 
 * @param {number} amount - Donation amount
 * @param {string} coin - Cryptocurrency (solana, stellar, bitcoin, ethereum)
 * @param {string} intentId - Optional: intentId from ContributionIntent (if from Mission Support)
 */
export async function cryptoButtonClick(amount, coin, intentId = null) {
    try {
        console.log('üí∞ Crypto button clicked:', { amount, coin, intentId });
        
        // Validate amount
        const validatedAmount = validateAmount(amount);
        if (!validatedAmount) {
            throw new Error('Invalid amount');
        }
        
        // CRITICAL: Enforce $30 minimum for crypto
        if (validatedAmount < 30) {
            throw new Error('Crypto payments require a minimum of $30');
        }
        
        // Validate coin
        const validCoins = ['solana', 'stellar', 'bitcoin', 'ethereum', 'SOL', 'XLM', 'BTC', 'ETH'];
        const normalizedCoin = coin.toLowerCase();
        if (!validCoins.includes(normalizedCoin)) {
            throw new Error('Invalid cryptocurrency');
        }
        
        // Map coin to NOWPayments format
        const payCurrencyMap = {
            'solana': 'SOL',
            'stellar': 'XLM',
            'bitcoin': 'BTC',
            'ethereum': 'ETH',
            'sol': 'SOL',
            'xlm': 'XLM',
            'btc': 'BTC',
            'eth': 'ETH'
        };
        
        const payCurrency = payCurrencyMap[normalizedCoin] || normalizedCoin.toUpperCase();
        
        // Get or create intentId
        let finalIntentId = intentId;
        
        if (!finalIntentId) {
            // Create new ContributionIntent if not provided
            const sessionId = await getSessionId();
            const intentRecord = {
                donationAmount: validatedAmount,
                paymentMethod: 'crypto',
                intentStatus: 'pending',
                source: 'charter_page',
                session_id: sessionId,
                timestamp: new Date(),
                metadata: {
                    paymentMethod: 'crypto',
                    coin: coin
                }
            };
            
            const savedIntent = await wixData.save('ContributionIntent', intentRecord);
            finalIntentId = savedIntent._id;
            console.log('‚úÖ Created new ContributionIntent with intentId:', finalIntentId);
        } else {
            // Update existing intent with crypto payment method
            try {
                const existingIntent = await wixData.get('ContributionIntent', finalIntentId);
                if (existingIntent) {
                    await wixData.update('ContributionIntent', {
                        ...existingIntent,
                        paymentMethod: 'crypto',
                        donationAmount: validatedAmount,
                        _updatedDate: new Date()
                    });
                }
            } catch (updateError) {
                console.warn('‚ö†Ô∏è Could not update existing intent:', updateError);
            }
        }
        
        // Create NOWPayments invoice with intentId as order_id (CUSTOM INVOICE ID)
        const invoiceResult = await createNowPaymentsInvoice({
            intentId: finalIntentId, // This becomes order_id in NOWPayments
            amount: validatedAmount,
            payCurrency: payCurrency,
            email: '', // Will be filled from session if available
            sessionId: await getSessionId(),
            firstName: '',
            lastName: '',
            source: 'charter_page'
        });
        
        if (!invoiceResult.success) {
            throw new Error(invoiceResult.error || 'Failed to create crypto invoice');
        }
        
        // Store invoice data in session
        await storeCryptoInvoiceData(invoiceResult);
        
        // Store donation amount
        await storeDonationAmount(validatedAmount, 'crypto', coin);
        
        return {
            success: true,
            invoiceId: invoiceResult.invoiceId,
            paymentUrl: invoiceResult.paymentUrl,
            payAddress: invoiceResult.payAddress,
            payAmountCrypto: invoiceResult.payAmountCrypto,
            payCurrency: invoiceResult.payCurrency,
            intentId: finalIntentId, // Return intentId for tracking
            orderId: finalIntentId // Custom invoice ID
        };
    } catch (error) {
        console.error('‚ùå Crypto button click error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Handle fiat button click (Stripe)
 * Creates Stripe checkout session for preset amounts
 */
export async function fiatButtonClick(preset) {
    try {
        console.log('üí≥ Fiat button clicked:', { preset });
        
        // Validate preset
        const validPresets = [1, 5, 20];
        const amount = parseFloat(preset);
        
        if (!validPresets.includes(amount)) {
            throw new Error('Invalid preset amount. Must be 1, 5, or 20');
        }
        
        // Get intentId if available (from URL parameters or create new)
        let intentId = null;
        try {
            // Try to get intentId from URL or session
            // This should be passed from Mission Support form
            const urlParams = new URLSearchParams(typeof window !== 'undefined' ? window.location.search : '');
            intentId = urlParams.get('intentId');
            
            if (!intentId) {
                // Create new ContributionIntent for Charter page direct access
                const sessionId = await getSessionId();
                const intentRecord = {
                    donationAmount: amount,
                    paymentMethod: 'card',
                    intentStatus: 'pending',
                    source: 'charter_page',
                    session_id: sessionId,
                    timestamp: new Date(),
                    metadata: { preset: amount }
                };
                const savedIntent = await wixData.save('ContributionIntent', intentRecord);
                intentId = savedIntent._id;
                console.log('‚úÖ Created new ContributionIntent for preset amount:', intentId);
            }
        } catch (intentError) {
            console.warn('‚ö†Ô∏è Could not get/create intentId:', intentError);
        }
        
        // Create Stripe checkout session with intentId
        const sessionResult = await createCheckoutSession({
            amount: amount,
            intentId: intentId, // Pass intentId for client_reference_id
            successUrl: `https://hingecraft-global.ai/charter?payment=success&intentId=${intentId}&session_id={CHECKOUT_SESSION_ID}`,
            cancelUrl: `https://hingecraft-global.ai/charter?payment=cancelled&intentId=${intentId}`,
            donationId: intentId,
            email: null,
            source: 'charter_page',
            isSubscription: false
        });
        
        if (!sessionResult.success) {
            throw new Error(sessionResult.error || 'Failed to create Stripe session');
        }
        
        // Store donation amount
        await storeDonationAmount(amount, 'stripe', null);
        
        return {
            success: true,
            sessionId: sessionResult.sessionId,
            url: sessionResult.url,
            amount: amount
        };
    } catch (error) {
        console.error('‚ùå Fiat button click error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Handle payment webhook
 * Updates database and totals after payment
 */
export async function afterPaymentWebhook(payload) {
    try {
        console.log('üì• Payment webhook received:', payload);
        
        const { paymentMethod, amount, transactionId, status, invoiceId } = payload;
        
        // Save donation to database
        const donationResult = await saveDonation({
            amount: amount,
            currency: 'USD',
            isOtherAmount: false,
            source: 'charter_page',
            paymentStatus: status || 'completed',
            paymentMethod: paymentMethod,
            transactionId: transactionId,
            email: payload.email || null,
            name: payload.name || null,
            metadata: {
                invoiceId: invoiceId,
                webhookPayload: payload
            }
        });
        
        // Update cumulative total
        const totalResult = await getCumulativeTotal();
        
        // Trigger contributions update
        await updateContributionsDisplay(totalResult.total);
        
        return {
            success: true,
            donationId: donationResult.donationId,
            cumulativeTotal: totalResult.total
        };
    } catch (error) {
        console.error('‚ùå Payment webhook error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Redirect back to charter page with state
 */
export async function redirectBackToCharter(donationAmount, paymentMethod) {
    try {
        const baseUrl = await getBaseUrl();
        const redirectUrl = `${baseUrl}/charter?donationAmount=${donationAmount}&paymentMethod=${paymentMethod}&fromMissionSupport=true`;
        
        return {
            success: true,
            redirectUrl: redirectUrl
        };
    } catch (error) {
        console.error('‚ùå Redirect error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Get cumulative total from database
 * Sums all completed donations (crypto + fiat)
 */
export async function getCumulativeTotal() {
    try {
        // Get all completed donations
        const donations = await wixData.query('Donations')
            .eq('payment_status', 'completed')
            .or(wixData.query('Donations').eq('payment_status', 'confirmed'))
            .find();
        
        // Get all confirmed crypto payments
        const cryptoPayments = await wixData.query('CryptoPayments')
            .eq('status', 'confirmed')
            .find();
        
        // Calculate totals
        let fiatTotal = 0;
        donations.items.forEach(donation => {
            if (donation.amount) {
                fiatTotal += parseFloat(donation.amount);
            }
        });
        
        let cryptoTotal = 0;
        cryptoPayments.items.forEach(payment => {
            if (payment.price_amount) {
                cryptoTotal += parseFloat(payment.price_amount);
            }
        });
        
        const total = fiatTotal + cryptoTotal;
        
        console.log('üí∞ Cumulative total calculated:', {
            fiatTotal,
            cryptoTotal,
            total
        });
        
        return {
            success: true,
            total: total,
            fiatTotal: fiatTotal,
            cryptoTotal: cryptoTotal,
            fiatCount: donations.items.length,
            cryptoCount: cryptoPayments.items.length
        };
    } catch (error) {
        console.error('‚ùå Error calculating cumulative total:', error);
        return {
            success: false,
            total: 0,
            error: error.message
        };
    }
}

/**
 * Update contributions display
 */
async function updateContributionsDisplay(total) {
    try {
        // This will be called from frontend to update the display
        // Store in session for frontend to pick up
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_cumulative_total', JSON.stringify({
                total: total,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error updating contributions display:', error);
    }
}

/**
 * Get donation amount from storage
 */
async function getDonationAmountFromStorage() {
    try {
        // Check URL parameters (handled by frontend)
        // Check session storage
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            const stored = wixStorage.session.getItem('hingecraft_donation');
            if (stored) {
                const data = JSON.parse(stored);
                if (data.amount) {
                    return parseFloat(data.amount);
                }
            }
        }
        return null;
    } catch (error) {
        console.error('Error getting donation amount:', error);
        return null;
    }
}

/**
 * Display donation amount
 */
async function displayDonationAmount(amount) {
    try {
        // Store for frontend to display
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_donation_display', JSON.stringify({
                amount: amount,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error storing donation display:', error);
    }
}

/**
 * Setup database change listeners
 */
function setupDatabaseListeners() {
    try {
        // Listen for changes to Donations collection
        wixData.onChange('Donations', async (changedItem) => {
            console.log('üìä Donations collection changed:', changedItem);
            
            // Recalculate total
            const totalResult = await getCumulativeTotal();
            await updateContributionsDisplay(totalResult.total);
        });
        
        // Listen for changes to CryptoPayments collection
        wixData.onChange('CryptoPayments', async (changedItem) => {
            console.log('üìä CryptoPayments collection changed:', changedItem);
            
            // Recalculate total
            const totalResult = await getCumulativeTotal();
            await updateContributionsDisplay(totalResult.total);
        });
    } catch (error) {
        console.error('Error setting up database listeners:', error);
    }
}

/**
 * Store crypto invoice data
 */
async function storeCryptoInvoiceData(invoiceData) {
    try {
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_crypto_invoice', JSON.stringify({
                invoiceId: invoiceData.invoiceId,
                paymentUrl: invoiceData.paymentUrl,
                payAddress: invoiceData.payAddress,
                payAmountCrypto: invoiceData.payAmountCrypto,
                payCurrency: invoiceData.payCurrency,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error storing crypto invoice:', error);
    }
}

/**
 * Store donation amount
 */
async function storeDonationAmount(amount, method, coin) {
    try {
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_donation', JSON.stringify({
                amount: amount,
                paymentMethod: method,
                coin: coin,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error storing donation amount:', error);
    }
}

/**
 * Get session ID
 */
async function getSessionId() {
    try {
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            let sessionId = wixStorage.session.getItem('hingecraft_session_id');
            if (!sessionId) {
                sessionId = 'hc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                wixStorage.session.setItem('hingecraft_session_id', sessionId);
            }
            return sessionId;
        }
        return 'hc_' + Date.now();
    } catch (error) {
        return 'hc_' + Date.now();
    }
}

/**
 * Get base URL
 */
async function getBaseUrl() {
    try {
        const { secrets } = await import('wix-secrets-backend');
        const baseUrl = await secrets.getSecret('BASE_URL');
        return baseUrl || 'https://www.hingecraft-global.ai';
    } catch (error) {
        return 'https://www.hingecraft-global.ai';
    }
}

/**
 * Validate amount
 */
function validateAmount(amount) {
    const n = Number(amount);
    if (!isFinite(n)) return null;
    
    const regex = /^\d{1,5}(\.\d{1,2})?$/;
    const rounded = Math.round(n * 100) / 100;
    
    if (!regex.test(String(rounded))) return null;
    if (rounded < 1.00 || rounded > 25000.00) return null;
    
    return rounded;
}
