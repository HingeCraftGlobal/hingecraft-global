/**
 * Charter Page Velo Middleware
 * T10 Implementation: Full middleware binding + dynamic totals + 2-page sync
 * 
 * Functions:
 * - onReady() â†’ check dataset â†’ update totals
 * - cryptoButtonClick(amount, coin) â†’ call NowPayments handler
 * - fiatButtonClick(preset) â†’ call Stripe dev key handler
 * - afterPaymentWebhook(payload) â†’ update DB + totals
 * - redirectBackToCharter() â†’ route with state
 * - getCumulativeTotal() â†’ calculate total from database
 */

import wixData from 'wix-data';
import { createNowPaymentsInvoice } from 'backend/nowpayments.api';
import { createCheckoutSession } from 'backend/stripe.api';
import { getLatestDonation, saveDonation } from 'backend/hingecraft.api.web';

/**
 * Initialize charter page on ready
 * Checks dataset and updates totals dynamically
 */
export async function onReady() {
    try {
        console.log('ðŸš€ Charter Page Middleware: onReady()');
        
        // Get cumulative total from database
        const totalResult = await getCumulativeTotal();
        
        // Update contributions section
        await updateContributionsDisplay(totalResult.total);
        
        // Check for donation amount in URL or storage
        const donationAmount = await getDonationAmountFromStorage();
        
        if (donationAmount && donationAmount > 0) {
            // Display donation amount
            await displayDonationAmount(donationAmount);
            
            // Update contributions with new amount
            await updateContributionsDisplay(totalResult.total + donationAmount);
        }
        
        // Setup database change listeners
        setupDatabaseListeners();
        
        return {
            success: true,
            cumulativeTotal: totalResult.total,
            donationAmount: donationAmount
        };
    } catch (error) {
        console.error('âŒ Charter Page onReady error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Handle crypto button click
 * Creates NOWPayments invoice for selected crypto
 */
export async function cryptoButtonClick(amount, coin) {
    try {
        console.log('ðŸ’° Crypto button clicked:', { amount, coin });
        
        // Validate amount
        const validatedAmount = validateAmount(amount);
        if (!validatedAmount) {
            throw new Error('Invalid amount');
        }
        
        // Validate coin
        const validCoins = ['solana', 'stellar', 'bitcoin', 'ethereum', 'SOL', 'XLM', 'BTC', 'ETH'];
        const normalizedCoin = coin.toLowerCase();
        if (!validCoins.includes(normalizedCoin)) {
            throw new Error('Invalid cryptocurrency');
        }
        
        // Map coin to NOWPayments format
        const payCurrencyMap = {
            'solana': 'SOL',
            'stellar': 'XLM',
            'bitcoin': 'BTC',
            'ethereum': 'ETH',
            'sol': 'SOL',
            'xlm': 'XLM',
            'btc': 'BTC',
            'eth': 'ETH'
        };
        
        const payCurrency = payCurrencyMap[normalizedCoin] || normalizedCoin.toUpperCase();
        
        // Generate intent ID
        const intentId = 'hc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        // Create NOWPayments invoice
        const invoiceResult = await createNowPaymentsInvoice({
            intentId: intentId,
            amount: validatedAmount,
            payCurrency: payCurrency,
            email: '', // Will be filled from session if available
            sessionId: await getSessionId(),
            firstName: '',
            lastName: ''
        });
        
        if (!invoiceResult.success) {
            throw new Error(invoiceResult.error || 'Failed to create crypto invoice');
        }
        
        // Store invoice data in session
        await storeCryptoInvoiceData(invoiceResult);
        
        // Store donation amount
        await storeDonationAmount(validatedAmount, 'crypto', coin);
        
        return {
            success: true,
            invoiceId: invoiceResult.invoiceId,
            paymentUrl: invoiceResult.paymentUrl,
            payAddress: invoiceResult.payAddress,
            payAmountCrypto: invoiceResult.payAmountCrypto,
            payCurrency: invoiceResult.payCurrency,
            intentId: intentId
        };
    } catch (error) {
        console.error('âŒ Crypto button click error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Handle fiat button click (Stripe)
 * Creates Stripe checkout session for preset amounts
 */
export async function fiatButtonClick(preset) {
    try {
        console.log('ðŸ’³ Fiat button clicked:', { preset });
        
        // Validate preset
        const validPresets = [1, 5, 20];
        const amount = parseFloat(preset);
        
        if (!validPresets.includes(amount)) {
            throw new Error('Invalid preset amount. Must be 1, 5, or 20');
        }
        
        // Create Stripe checkout session
        const sessionResult = await createCheckoutSession({
            amount: amount,
            successUrl: `${await getBaseUrl()}/payment-success?amount=${amount}&method=stripe`,
            cancelUrl: `${await getBaseUrl()}/charter?canceled=true&amount=${amount}`,
            donationId: null,
            email: null
        });
        
        if (!sessionResult.success) {
            throw new Error(sessionResult.error || 'Failed to create Stripe session');
        }
        
        // Store donation amount
        await storeDonationAmount(amount, 'stripe', null);
        
        return {
            success: true,
            sessionId: sessionResult.sessionId,
            url: sessionResult.url,
            amount: amount
        };
    } catch (error) {
        console.error('âŒ Fiat button click error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Handle payment webhook
 * Updates database and totals after payment
 */
export async function afterPaymentWebhook(payload) {
    try {
        console.log('ðŸ“¥ Payment webhook received:', payload);
        
        const { paymentMethod, amount, transactionId, status, invoiceId } = payload;
        
        // Save donation to database
        const donationResult = await saveDonation({
            amount: amount,
            currency: 'USD',
            isOtherAmount: false,
            source: 'charter_page',
            paymentStatus: status || 'completed',
            paymentMethod: paymentMethod,
            transactionId: transactionId,
            email: payload.email || null,
            name: payload.name || null,
            metadata: {
                invoiceId: invoiceId,
                webhookPayload: payload
            }
        });
        
        // Update cumulative total
        const totalResult = await getCumulativeTotal();
        
        // Trigger contributions update
        await updateContributionsDisplay(totalResult.total);
        
        return {
            success: true,
            donationId: donationResult.donationId,
            cumulativeTotal: totalResult.total
        };
    } catch (error) {
        console.error('âŒ Payment webhook error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Redirect back to charter page with state
 */
export async function redirectBackToCharter(donationAmount, paymentMethod) {
    try {
        const baseUrl = await getBaseUrl();
        const redirectUrl = `${baseUrl}/charter?donationAmount=${donationAmount}&paymentMethod=${paymentMethod}&fromMissionSupport=true`;
        
        return {
            success: true,
            redirectUrl: redirectUrl
        };
    } catch (error) {
        console.error('âŒ Redirect error:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Get cumulative total from database
 * Sums all completed donations (crypto + fiat)
 */
export async function getCumulativeTotal() {
    try {
        // Get all completed donations
        const donations = await wixData.query('Donations')
            .eq('payment_status', 'completed')
            .or(wixData.query('Donations').eq('payment_status', 'confirmed'))
            .find();
        
        // Get all confirmed crypto payments
        const cryptoPayments = await wixData.query('CryptoPayments')
            .eq('status', 'confirmed')
            .find();
        
        // Calculate totals
        let fiatTotal = 0;
        donations.items.forEach(donation => {
            if (donation.amount) {
                fiatTotal += parseFloat(donation.amount);
            }
        });
        
        let cryptoTotal = 0;
        cryptoPayments.items.forEach(payment => {
            if (payment.price_amount) {
                cryptoTotal += parseFloat(payment.price_amount);
            }
        });
        
        const total = fiatTotal + cryptoTotal;
        
        console.log('ðŸ’° Cumulative total calculated:', {
            fiatTotal,
            cryptoTotal,
            total
        });
        
        return {
            success: true,
            total: total,
            fiatTotal: fiatTotal,
            cryptoTotal: cryptoTotal,
            fiatCount: donations.items.length,
            cryptoCount: cryptoPayments.items.length
        };
    } catch (error) {
        console.error('âŒ Error calculating cumulative total:', error);
        return {
            success: false,
            total: 0,
            error: error.message
        };
    }
}

/**
 * Update contributions display
 */
async function updateContributionsDisplay(total) {
    try {
        // This will be called from frontend to update the display
        // Store in session for frontend to pick up
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_cumulative_total', JSON.stringify({
                total: total,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error updating contributions display:', error);
    }
}

/**
 * Get donation amount from storage
 */
async function getDonationAmountFromStorage() {
    try {
        // Check URL parameters (handled by frontend)
        // Check session storage
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            const stored = wixStorage.session.getItem('hingecraft_donation');
            if (stored) {
                const data = JSON.parse(stored);
                if (data.amount) {
                    return parseFloat(data.amount);
                }
            }
        }
        return null;
    } catch (error) {
        console.error('Error getting donation amount:', error);
        return null;
    }
}

/**
 * Display donation amount
 */
async function displayDonationAmount(amount) {
    try {
        // Store for frontend to display
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_donation_display', JSON.stringify({
                amount: amount,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error storing donation display:', error);
    }
}

/**
 * Setup database change listeners
 */
function setupDatabaseListeners() {
    try {
        // Listen for changes to Donations collection
        wixData.onChange('Donations', async (changedItem) => {
            console.log('ðŸ“Š Donations collection changed:', changedItem);
            
            // Recalculate total
            const totalResult = await getCumulativeTotal();
            await updateContributionsDisplay(totalResult.total);
        });
        
        // Listen for changes to CryptoPayments collection
        wixData.onChange('CryptoPayments', async (changedItem) => {
            console.log('ðŸ“Š CryptoPayments collection changed:', changedItem);
            
            // Recalculate total
            const totalResult = await getCumulativeTotal();
            await updateContributionsDisplay(totalResult.total);
        });
    } catch (error) {
        console.error('Error setting up database listeners:', error);
    }
}

/**
 * Store crypto invoice data
 */
async function storeCryptoInvoiceData(invoiceData) {
    try {
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_crypto_invoice', JSON.stringify({
                invoiceId: invoiceData.invoiceId,
                paymentUrl: invoiceData.paymentUrl,
                payAddress: invoiceData.payAddress,
                payAmountCrypto: invoiceData.payAmountCrypto,
                payCurrency: invoiceData.payCurrency,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error storing crypto invoice:', error);
    }
}

/**
 * Store donation amount
 */
async function storeDonationAmount(amount, method, coin) {
    try {
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            wixStorage.session.setItem('hingecraft_donation', JSON.stringify({
                amount: amount,
                paymentMethod: method,
                coin: coin,
                timestamp: new Date().toISOString()
            }));
        }
    } catch (error) {
        console.error('Error storing donation amount:', error);
    }
}

/**
 * Get session ID
 */
async function getSessionId() {
    try {
        if (typeof wixStorage !== 'undefined' && wixStorage.session) {
            let sessionId = wixStorage.session.getItem('hingecraft_session_id');
            if (!sessionId) {
                sessionId = 'hc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                wixStorage.session.setItem('hingecraft_session_id', sessionId);
            }
            return sessionId;
        }
        return 'hc_' + Date.now();
    } catch (error) {
        return 'hc_' + Date.now();
    }
}

/**
 * Get base URL
 */
async function getBaseUrl() {
    try {
        const { secrets } = await import('wix-secrets-backend');
        const baseUrl = await secrets.getSecret('BASE_URL');
        return baseUrl || 'https://www.hingecraft-global.ai';
    } catch (error) {
        return 'https://www.hingecraft-global.ai';
    }
}

/**
 * Validate amount
 */
function validateAmount(amount) {
    const n = Number(amount);
    if (!isFinite(n)) return null;
    
    const regex = /^\d{1,5}(\.\d{1,2})?$/;
    const rounded = Math.round(n * 100) / 100;
    
    if (!regex.test(String(rounded))) return null;
    if (rounded < 1.00 || rounded > 25000.00) return null;
    
    return rounded;
}
