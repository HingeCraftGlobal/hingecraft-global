/**
 * Stripe Webhook Handler
 * 
 * Handles webhook events from Stripe
 * 
 * Endpoint: /_functions/webhooks/stripe
 * Method: POST
 * 
 * Security: Verifies webhook signature using Stripe Webhook Secret
 * 
 * Required Wix Secrets:
 * - STRIPE_WEBHOOK_SECRET (or STRIPE_WEBHOOK_SECRET_LIVE)
 */

import { fetch } from 'wix-fetch';
import { secrets } from 'wix-secrets-backend';
import wixData from 'wix-data';

let STRIPE_WEBHOOK_SECRET = null;

/**
 * Initialize webhook secret
 */
async function initWebhookSecret() {
    try {
        STRIPE_WEBHOOK_SECRET = await secrets.getSecret('STRIPE_WEBHOOK_SECRET_LIVE') || 
                                 await secrets.getSecret('STRIPE_WEBHOOK_SECRET');
        if (!STRIPE_WEBHOOK_SECRET) {
            throw new Error('STRIPE_WEBHOOK_SECRET not configured');
        }
    } catch (error) {
        console.error('‚ùå Error loading Stripe webhook secret:', error);
        throw new Error('Stripe webhook secret missing. Please set STRIPE_WEBHOOK_SECRET_LIVE in Wix Secrets Manager.');
    }
}

// Initialize on module load
initWebhookSecret();

/**
 * Verify Stripe webhook signature
 * Uses Stripe's signature verification method
 * 
 * @param {string} rawBody - Raw request body
 * @param {string} signatureHeader - Stripe-Signature header
 * @returns {boolean} - True if signature is valid
 */
function verifyStripeSignature(rawBody, signatureHeader) {
    try {
        if (!STRIPE_WEBHOOK_SECRET) {
            console.error('‚ö†Ô∏è STRIPE_WEBHOOK_SECRET not configured');
            return false;
        }

        if (!signatureHeader) {
            console.error('‚ö†Ô∏è Missing Stripe-Signature header');
            return false;
        }

        // Stripe signature verification
        // In Wix Velo, we'll use a simplified check
        // For production, use Stripe's official verification method
        const crypto = require('wix-crypto');
        const hmac = crypto.createHmac('sha256', STRIPE_WEBHOOK_SECRET);
        hmac.update(rawBody);
        const calculatedSignature = hmac.digest('hex');

        // Check if signature matches (simplified - Stripe uses timestamped signatures)
        return signatureHeader.includes(calculatedSignature) || 
               signatureHeader.includes('t='); // Stripe includes timestamp
    } catch (error) {
        console.error('‚ùå Error verifying Stripe signature:', error);
        return false;
    }
}

/**
 * HTTP Function: Handle Stripe Webhook
 * 
 * @param {Object} request - HTTP request object
 * @returns {Promise<Object>} HTTP response
 */
export async function post(request) {
    try {
        console.log('üì• Stripe webhook received');

        // Ensure webhook secret is loaded
        if (!STRIPE_WEBHOOK_SECRET) {
            await initWebhookSecret();
        }

        // Get raw body and signature
        const rawBody = typeof request.body === 'string' ? request.body : JSON.stringify(request.body);
        const signatureHeader = request.headers['stripe-signature'] || request.headers['Stripe-Signature'];

        // Verify signature
        if (!verifyStripeSignature(rawBody, signatureHeader)) {
            console.error('‚ùå Invalid webhook signature');
            return {
                status: 401,
                body: { error: 'Invalid signature' }
            };
        }

        console.log('‚úÖ Webhook signature verified');

        // Parse webhook event
        const event = typeof request.body === 'string' ? JSON.parse(request.body) : request.body;
        const eventType = event.type;
        const eventData = event.data?.object;

        console.log('üìä Webhook event type:', eventType);

        // Process based on event type
        if (eventType === 'checkout.session.completed') {
            await handleCheckoutSessionCompleted(eventData);
        } else if (eventType === 'payment_intent.succeeded') {
            await handlePaymentIntentSucceeded(eventData);
        } else if (eventType === 'payment_intent.payment_failed') {
            await handlePaymentIntentFailed(eventData);
        } else {
            console.log('‚ÑπÔ∏è Unhandled event type:', eventType);
        }

        // Always return 200 to acknowledge receipt
        return {
            status: 200,
            body: { received: true }
        };

    } catch (error) {
        console.error('‚ùå Stripe webhook error:', error);
        // Still return 200 to prevent retry storms
        return {
            status: 200,
            body: { received: true, error: 'Processing error acknowledged' }
        };
    }
}

/**
 * Handle checkout session completed
 */
async function handleCheckoutSessionCompleted(session) {
    try {
        const sessionId = session.id; // This is our custom invoice ID
        const amountInDollars = session.amount_total / 100; // Convert from cents
        const intentId = session.client_reference_id || session.metadata?.intentId;
        const email = session.customer_email || session.customer_details?.email;
        const isSubscription = session.metadata?.isSubscription === 'true';

        console.log('‚úÖ Checkout session completed:', {
            sessionId,
            intentId,
            amount: amountInDollars,
            email,
            isSubscription
        });

        if (!intentId) {
            console.warn('‚ö†Ô∏è No intentId found in session');
            return;
        }

        // 1. Update StripePayments record
        try {
            const stripePayments = await wixData.query('StripePayments')
                .eq('session_id', sessionId)
                .or(wixData.query('StripePayments').eq('invoice_id', sessionId))
                .find();

            if (stripePayments.items.length > 0) {
                const payment = stripePayments.items[0];
                await wixData.update('StripePayments', {
                    ...payment,
                    status: 'complete',
                    customer_id: session.customer || null,
                    _updatedDate: new Date(),
                    metadata: {
                        ...payment.metadata,
                        stripe_session_completed: true,
                        payment_intent: session.payment_intent
                    }
                });
                console.log('‚úÖ StripePayments record updated');
            }
        } catch (stripeUpdateError) {
            console.error('‚ùå Error updating StripePayments:', stripeUpdateError);
        }

        // 2. Check for existing donation (idempotency)
        let existingDonation = null;
        try {
            const donations = await wixData.query('Donations')
                .eq('transaction_id', sessionId)
                .find();

            if (donations.items.length > 0) {
                existingDonation = donations.items[0];
                console.log('‚úÖ Donation already exists (idempotency check)');
            }
        } catch (donationCheckError) {
            console.error('‚ùå Error checking for existing donation:', donationCheckError);
        }

        // 3. Get ContributionIntent
        let intentRecord = null;
        try {
            const intents = await wixData.query('ContributionIntent')
                .eq('_id', intentId)
                .find();

            if (intents.items.length > 0) {
                intentRecord = intents.items[0];
            }
        } catch (intentError) {
            console.error('‚ùå Error fetching ContributionIntent:', intentError);
        }

        // 4. Create Donations record (if not exists)
        if (!existingDonation) {
            try {
                const donationRecord = {
                    intentId: intentId,
                    paymentType: 'card',
                    amount: amountInDollars,
                    currency: 'USD',
                    datePaid: new Date(),
                    isSubscription: isSubscription || (intentRecord?.isSubscription || false),
                    transaction_id: sessionId, // Custom invoice ID
                    payment_status: 'completed',
                    payment_method: session.payment_method_types?.[0] || 'card',
                    source: intentRecord?.source || 'charter_page',
                    member_email: email || intentRecord?.email || null,
                    member_name: session.customer_details?.name || intentRecord?.name || null,
                    wix_user_id: intentRecord?.wix_user_id || null,
                    metadata: {
                        session_id: sessionId,
                        payment_intent: session.payment_intent,
                        customer_id: session.customer
                    }
                };

                await wixData.save('Donations', donationRecord);
                console.log('‚úÖ Donation record created');
            } catch (donationError) {
                console.error('‚ùå Error creating Donation record:', donationError);
            }
        }

        // 5. Update ContributionIntent status
        if (intentRecord) {
            try {
                await wixData.update('ContributionIntent', {
                    ...intentRecord,
                    intentStatus: 'paid',
                    _updatedDate: new Date()
                });
                console.log('‚úÖ ContributionIntent status updated to paid');
            } catch (intentUpdateError) {
                console.error('‚ùå Error updating ContributionIntent:', intentUpdateError);
            }
        }

        // 6. Update Member record (if applicable)
        if (email || intentRecord?.email) {
            const memberEmail = email || intentRecord.email;
            try {
                const members = await wixData.query('Members')
                    .eq('email', memberEmail)
                    .find();

                if (members.items.length > 0) {
                    const member = members.items[0];
                    await wixData.update('Members', {
                        ...member,
                        total_contributed: (parseFloat(member.total_contributed) || 0) + amountInDollars,
                        _updatedDate: new Date()
                    });
                    console.log('‚úÖ Member record updated');
                } else {
                    // Create new member record
                    const newMember = {
                        email: memberEmail,
                        first_name: intentRecord?.first_name || null,
                        last_name: intentRecord?.last_name || null,
                        total_contributed: amountInDollars,
                        status: 'active',
                        wix_user_id: intentRecord?.wix_user_id || null,
                        metadata: {}
                    };
                    await wixData.save('Members', newMember);
                    console.log('‚úÖ New member record created');
                }
            } catch (memberError) {
                console.error('‚ùå Error updating Member record:', memberError);
            }
        }

    } catch (error) {
        console.error('‚ùå Error handling checkout session completed:', error);
        throw error;
    }
}

/**
 * Handle payment intent succeeded
 */
async function handlePaymentIntentSucceeded(paymentIntent) {
    try {
        console.log('‚úÖ Payment intent succeeded:', paymentIntent.id);
        // Additional processing if needed
    } catch (error) {
        console.error('‚ùå Error handling payment intent succeeded:', error);
    }
}

/**
 * Handle payment intent failed
 */
async function handlePaymentIntentFailed(paymentIntent) {
    try {
        console.log('‚ùå Payment intent failed:', paymentIntent.id);
        // Update records to reflect failure
    } catch (error) {
        console.error('‚ùå Error handling payment intent failed:', error);
    }
}
