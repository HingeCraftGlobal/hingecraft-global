/**
 * Stripe API Integration for Wix Velo
 * 
 * This module handles:
 * - Stripe checkout session creation
 * - Payment processing
 * - Custom invoice creation
 * - Webhook handling
 * - Publishable key retrieval
 * 
 * Required Wix Secrets (TEST keys prioritized for dev):
 * - STRIPE_SECRET_KEY_TEST (DEV - prioritized)
 * - STRIPE_PUBLISHABLE_KEY_TEST (DEV - prioritized)
 * - STRIPE_SECRET_KEY_LIVE (PROD - fallback)
 * - STRIPE_PUBLISHABLE_KEY_LIVE (PROD - fallback)
 */

import { fetch } from 'wix-fetch';
import { secrets } from 'wix-secrets-backend';
import wixData from 'wix-data';

// Stripe API configuration
const STRIPE_API_BASE = 'https://api.stripe.com/v1';
let STRIPE_SECRET_KEY = null;
let STRIPE_PUBLISHABLE_KEY = null;
let STRIPE_MODE = 'test'; // 'test' or 'live'

/**
 * Initialize Stripe configuration from secrets
 * Prioritizes TEST keys for development
 */
async function initStripeConfig() {
    try {
        // Try TEST keys first (DEV mode)
        try {
            STRIPE_SECRET_KEY = await secrets.getSecret('STRIPE_SECRET_KEY_TEST');
            STRIPE_MODE = 'test';
            console.log('üîß Using Stripe TEST keys (DEV mode)');
        } catch (testError) {
            // Fallback to LIVE keys (PROD mode)
            try {
                STRIPE_SECRET_KEY = await secrets.getSecret('STRIPE_SECRET_KEY_LIVE');
                STRIPE_MODE = 'live';
                console.log('üîß Using Stripe LIVE keys (PROD mode)');
            } catch (liveError) {
                throw new Error('No Stripe keys found. Please set STRIPE_SECRET_KEY_TEST (dev) or STRIPE_SECRET_KEY_LIVE (prod) in Wix Secrets Manager.');
            }
        }
        
        // Try to get publishable key from secrets, or derive from secret key
        try {
            if (STRIPE_MODE === 'test') {
                STRIPE_PUBLISHABLE_KEY = await secrets.getSecret('STRIPE_PUBLISHABLE_KEY_TEST');
            } else {
                STRIPE_PUBLISHABLE_KEY = await secrets.getSecret('STRIPE_PUBLISHABLE_KEY_LIVE');
            }
        } catch (e) {
            // Derive publishable key from secret key
            // Format: sk_test_... -> pk_test_... or sk_live_... -> pk_live_...
            if (STRIPE_SECRET_KEY && STRIPE_SECRET_KEY.startsWith('sk_test_')) {
                STRIPE_PUBLISHABLE_KEY = STRIPE_SECRET_KEY.replace('sk_test_', 'pk_test_');
            } else if (STRIPE_SECRET_KEY && STRIPE_SECRET_KEY.startsWith('sk_live_')) {
                STRIPE_PUBLISHABLE_KEY = STRIPE_SECRET_KEY.replace('sk_live_', 'pk_live_');
            } else {
                throw new Error('Could not derive publishable key from secret key');
            }
        }
        
        if (!STRIPE_SECRET_KEY) {
            throw new Error('STRIPE_SECRET_KEY not configured in Wix Secrets');
        }
        
        if (!STRIPE_PUBLISHABLE_KEY) {
            throw new Error('STRIPE_PUBLISHABLE_KEY not configured in Wix Secrets');
        }
        
        console.log(`‚úÖ Stripe configuration loaded (${STRIPE_MODE.toUpperCase()} mode)`);
        console.log(`   Secret key: ${STRIPE_SECRET_KEY.substring(0, 12)}...`);
        console.log(`   Publishable key: ${STRIPE_PUBLISHABLE_KEY.substring(0, 12)}...`);
    } catch (error) {
        console.error('‚ùå Error loading Stripe configuration:', error);
        throw new Error(`Stripe configuration missing: ${error.message}`);
    }
}

// Initialize on module load
initStripeConfig();

/**
 * Get Stripe publishable key
 * @returns {Promise<Object>} Publishable key response
 */
export async function getPublishableKey() {
    try {
        if (!STRIPE_PUBLISHABLE_KEY) {
            await initStripeConfig();
        }
        
        return {
            success: true,
            publishableKey: STRIPE_PUBLISHABLE_KEY
        };
    } catch (error) {
        console.error('‚ùå Error getting publishable key:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

/**
 * Create Stripe checkout session
 * @param {Object} requestData - Checkout session data
 * @param {number} requestData.amount - Amount in USD (e.g., 10.50)
 * @param {string} requestData.successUrl - Success redirect URL
 * @param {string} requestData.cancelUrl - Cancel redirect URL
 * @param {string} requestData.donationId - Optional donation ID
 * @param {string} requestData.email - Optional donor email
 * @returns {Promise<Object>} Checkout session response
 */
export async function createCheckoutSession(requestData) {
    try {
        // Ensure config is loaded
        if (!STRIPE_SECRET_KEY) {
            await initStripeConfig();
        }

        // Validate required fields
        if (!requestData || !requestData.amount) {
            throw new Error('Amount is required');
        }

        const amount = parseFloat(requestData.amount);
        if (isNaN(amount) || amount < 1.00 || amount > 25000.00) {
            throw new Error('Invalid amount (must be between $1.00 and $25,000.00)');
        }

        // Convert to cents (Stripe uses cents)
        const amountInCents = Math.round(amount * 100);

        // Build checkout session payload
        const sessionData = {
            payment_method_types: ['card'],
            line_items: [{
                price_data: {
                    currency: 'usd',
                    product_data: {
                        name: 'HingeCraft Donation',
                        description: 'Mission Support Contribution'
                    },
                    unit_amount: amountInCents
                },
                quantity: 1
            }],
            mode: 'payment',
            success_url: requestData.successUrl || `${requestData.baseUrl || 'https://www.hingecraft-global.ai'}/payment-success?amount=${amount}&method=stripe`,
            cancel_url: requestData.cancelUrl || `${requestData.baseUrl || 'https://www.hingecraft-global.ai'}/charter?canceled=true`,
            metadata: {
                donationId: requestData.donationId || '',
                source: 'charter_page',
                amount: amount.toString()
            }
        };

        // Add customer email if provided
        if (requestData.email) {
            sessionData.customer_email = requestData.email;
        }

        // Call Stripe API
        const response = await fetch(`${STRIPE_API_BASE}/checkout/sessions`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${STRIPE_SECRET_KEY}`,
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams(sessionData).toString()
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error('‚ùå Stripe API error:', response.status, errorText);
            throw new Error(`Stripe API error: ${response.status} - ${errorText}`);
        }

        const session = await response.json();

        // Store payment intent in database
        try {
            const paymentRecord = {
                _id: session.id,
                session_id: session.id,
                amount: amount,
                currency: 'usd',
                status: 'pending',
                payment_method: 'stripe',
                donation_id: requestData.donationId || null,
                email: requestData.email || null,
                created_at: new Date(),
                metadata: {
                    stripe_session_id: session.id,
                    stripe_payment_intent: session.payment_intent || null
                }
            };

            await wixData.save('StripePayments', paymentRecord);
        } catch (dbError) {
            console.error('‚ö†Ô∏è  Error saving payment record (non-blocking):', dbError);
            // Don't fail the request if database save fails
        }

        return {
            success: true,
            sessionId: session.id,
            url: session.url,
            paymentIntent: session.payment_intent
        };

    } catch (error) {
        console.error('‚ùå Error creating checkout session:', error);
        throw error;
    }
}

/**
 * Handle Stripe webhook
 * @param {Object} eventData - Stripe webhook event data
 * @returns {Promise<Object>} Webhook processing result
 */
export async function handleWebhook(eventData) {
    try {
        const eventType = eventData.type;
        const eventDataObj = eventData.data?.object;

        console.log('üì• Stripe webhook received:', eventType);

        switch (eventType) {
            case 'checkout.session.completed':
                await handleCheckoutSessionCompleted(eventDataObj);
                break;
            case 'payment_intent.succeeded':
                await handlePaymentIntentSucceeded(eventDataObj);
                break;
            case 'payment_intent.payment_failed':
                await handlePaymentIntentFailed(eventDataObj);
                break;
            default:
                console.log('‚ÑπÔ∏è  Unhandled webhook event type:', eventType);
        }

        return {
            success: true,
            processed: true
        };

    } catch (error) {
        console.error('‚ùå Error processing webhook:', error);
        throw error;
    }
}

/**
 * Handle checkout session completed
 */
async function handleCheckoutSessionCompleted(session) {
    try {
        const sessionId = session.id;
        const amount = session.amount_total / 100; // Convert from cents
        const email = session.customer_email || session.customer_details?.email;

        // Update payment record
        const results = await wixData.query('StripePayments')
            .eq('session_id', sessionId)
            .find();

        if (results.items.length > 0) {
            const payment = results.items[0];
            await wixData.update('StripePayments', {
                ...payment,
                status: 'completed',
                email: email || payment.email,
                completed_at: new Date(),
                metadata: {
                    ...payment.metadata,
                    stripe_session_completed: true
                }
            });
        }

        // Update donation record if exists
        if (session.metadata?.donationId) {
            try {
                const donation = await wixData.get('Donations', session.metadata.donationId);
                if (donation) {
                    await wixData.update('Donations', {
                        ...donation,
                        payment_status: 'completed',
                        payment_method: 'stripe',
                        transaction_id: session.payment_intent,
                        updated_at: new Date()
                    });
                }
            } catch (e) {
                console.error('Error updating donation:', e);
            }
        }

        console.log('‚úÖ Checkout session completed:', sessionId);
    } catch (error) {
        console.error('‚ùå Error handling checkout session completed:', error);
        throw error;
    }
}

/**
 * Handle payment intent succeeded
 */
async function handlePaymentIntentSucceeded(paymentIntent) {
    try {
        const paymentIntentId = paymentIntent.id;
        const amount = paymentIntent.amount / 100;

        // Update payment records
        const results = await wixData.query('StripePayments')
            .contains('metadata.stripe_payment_intent', paymentIntentId)
            .find();

        for (const payment of results.items) {
            await wixData.update('StripePayments', {
                ...payment,
                status: 'completed',
                completed_at: new Date(),
                metadata: {
                    ...payment.metadata,
                    stripe_payment_intent_succeeded: true
                }
            });
        }

        console.log('‚úÖ Payment intent succeeded:', paymentIntentId);
    } catch (error) {
        console.error('‚ùå Error handling payment intent succeeded:', error);
        throw error;
    }
}

/**
 * Handle payment intent failed
 */
async function handlePaymentIntentFailed(paymentIntent) {
    try {
        const paymentIntentId = paymentIntent.id;

        // Update payment records
        const results = await wixData.query('StripePayments')
            .contains('metadata.stripe_payment_intent', paymentIntentId)
            .find();

        for (const payment of results.items) {
            await wixData.update('StripePayments', {
                ...payment,
                status: 'failed',
                failed_at: new Date(),
                metadata: {
                    ...payment.metadata,
                    stripe_payment_intent_failed: true,
                    failure_reason: paymentIntent.last_payment_error?.message || 'Unknown error'
                }
            });
        }

        console.log('‚ùå Payment intent failed:', paymentIntentId);
    } catch (error) {
        console.error('‚ùå Error handling payment intent failed:', error);
        throw error;
    }
}

/**
 * Get payment status
 * @param {string} sessionId - Stripe checkout session ID
 * @returns {Promise<Object>} Payment status
 */
export async function getPaymentStatus(sessionId) {
    try {
        if (!STRIPE_SECRET_KEY) {
            await initStripeConfig();
        }

        // Get from Stripe API
        const response = await fetch(`${STRIPE_API_BASE}/checkout/sessions/${sessionId}`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${STRIPE_SECRET_KEY}`
            }
        });

        if (!response.ok) {
            throw new Error(`Stripe API error: ${response.status}`);
        }

        const session = await response.json();

        return {
            success: true,
            status: session.payment_status,
            amount: session.amount_total / 100,
            currency: session.currency,
            email: session.customer_email
        };

    } catch (error) {
        console.error('‚ùå Error getting payment status:', error);
        throw error;
    }
}

/**
 * Create custom Stripe invoice
 * Creates an invoice with custom line items and sends it to customer
 * @param {Object} invoiceData - Invoice data
 * @param {number} invoiceData.amount - Amount in USD
 * @param {string} invoiceData.email - Customer email
 * @param {string} invoiceData.description - Invoice description
 * @param {string} invoiceData.customerName - Optional customer name
 * @param {Object} invoiceData.metadata - Optional metadata
 * @returns {Promise<Object>} Invoice creation response
 */
export async function createCustomInvoice(invoiceData) {
    try {
        // Ensure config is loaded
        if (!STRIPE_SECRET_KEY) {
            await initStripeConfig();
        }

        // Validate required fields
        if (!invoiceData || !invoiceData.amount || !invoiceData.email) {
            throw new Error('Amount and email are required');
        }

        const amount = parseFloat(invoiceData.amount);
        if (isNaN(amount) || amount < 1.00 || amount > 25000.00) {
            throw new Error('Invalid amount (must be between $1.00 and $25,000.00)');
        }

        // Convert to cents (Stripe uses cents)
        const amountInCents = Math.round(amount * 100);

        // Step 1: Create or retrieve customer
        let customerId = null;
        try {
            // Try to find existing customer by email
            const customerSearchResponse = await fetch(`${STRIPE_API_BASE}/customers/search?query=email:'${encodeURIComponent(invoiceData.email)}'`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${STRIPE_SECRET_KEY}`
                }
            });

            if (customerSearchResponse.ok) {
                const customerSearch = await customerSearchResponse.json();
                if (customerSearch.data && customerSearch.data.length > 0) {
                    customerId = customerSearch.data[0].id;
                    console.log('‚úÖ Found existing customer:', customerId);
                }
            }

            // If no customer found, create one
            if (!customerId) {
                const customerData = {
                    email: invoiceData.email,
                    name: invoiceData.customerName || null,
                    metadata: invoiceData.metadata || {}
                };

                const customerResponse = await fetch(`${STRIPE_API_BASE}/customers`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${STRIPE_SECRET_KEY}`,
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: new URLSearchParams(customerData).toString()
                });

                if (!customerResponse.ok) {
                    const errorText = await customerResponse.text();
                    throw new Error(`Failed to create customer: ${errorText}`);
                }

                const customer = await customerResponse.json();
                customerId = customer.id;
                console.log('‚úÖ Created new customer:', customerId);
            }
        } catch (customerError) {
            console.error('‚ùå Error with customer:', customerError);
            throw new Error(`Customer creation/retrieval failed: ${customerError.message}`);
        }

        // Step 2: Create invoice item
        const invoiceItemData = {
            customer: customerId,
            amount: amountInCents,
            currency: 'usd',
            description: invoiceData.description || 'HingeCraft Donation - Mission Support Contribution'
        };

        const invoiceItemResponse = await fetch(`${STRIPE_API_BASE}/invoiceitems`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${STRIPE_SECRET_KEY}`,
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams(invoiceItemData).toString()
        });

        if (!invoiceItemResponse.ok) {
            const errorText = await invoiceItemResponse.text();
            throw new Error(`Failed to create invoice item: ${errorText}`);
        }

        const invoiceItem = await invoiceItemResponse.json();
        console.log('‚úÖ Created invoice item:', invoiceItem.id);

        // Step 3: Create invoice (charge automatically, no email sent)
        const invoicePayload = {
            customer: customerId,
            collection_method: 'charge_automatically',
            auto_advance: false, // Don't automatically finalize
            metadata: {
                ...(invoiceData.metadata || {}),
                source: 'custom_invoice',
                mode: STRIPE_MODE
            }
        };

        const invoiceResponse = await fetch(`${STRIPE_API_BASE}/invoices`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${STRIPE_SECRET_KEY}`,
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams(invoicePayload).toString()
        });

        if (!invoiceResponse.ok) {
            const errorText = await invoiceResponse.text();
            throw new Error(`Failed to create invoice: ${errorText}`);
        }

        const invoice = await invoiceResponse.json();
        console.log('‚úÖ Created invoice:', invoice.id);

        // Step 4: Finalize invoice (make it payable, but DO NOT send email)
        const finalizeResponse = await fetch(`${STRIPE_API_BASE}/invoices/${invoice.id}/finalize`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${STRIPE_SECRET_KEY}`,
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: new URLSearchParams({ auto_advance: 'false' }).toString() // Don't auto-advance
        });

        if (!finalizeResponse.ok) {
            const errorText = await finalizeResponse.text();
            throw new Error(`Failed to finalize invoice: ${errorText}`);
        }

        const finalizedInvoice = await finalizeResponse.json();
        console.log('‚úÖ Finalized invoice (not sent via email):', finalizedInvoice.id);
        
        // NOTE: Invoice is created and finalized in Stripe but NOT sent via email
        // Customer can access via invoice_url or invoice_pdf links

        // Store invoice in database
        try {
            const invoiceRecord = {
                _id: finalizedInvoice.id,
                invoice_id: finalizedInvoice.id,
                customer_id: customerId,
                amount: amount,
                currency: 'usd',
                status: finalizedInvoice.status,
                invoice_url: finalizedInvoice.hosted_invoice_url,
                invoice_pdf: finalizedInvoice.invoice_pdf,
                email: invoiceData.email,
                created_at: new Date(),
                metadata: {
                    stripe_invoice_id: finalizedInvoice.id,
                    stripe_customer_id: customerId,
                    mode: STRIPE_MODE,
                    ...(invoiceData.metadata || {})
                }
            };

            await wixData.save('StripePayments', invoiceRecord);
        } catch (dbError) {
            console.error('‚ö†Ô∏è  Error saving invoice record (non-blocking):', dbError);
        }

        return {
            success: true,
            invoiceId: finalizedInvoice.id,
            invoiceUrl: finalizedInvoice.hosted_invoice_url,
            invoicePdf: finalizedInvoice.invoice_pdf,
            customerId: customerId,
            amount: amount,
            status: finalizedInvoice.status,
            mode: STRIPE_MODE
        };

    } catch (error) {
        console.error('‚ùå Error creating custom invoice:', error);
        throw error;
    }
}

/**
 * Get Stripe mode (test or live)
 * @returns {Promise<Object>} Stripe mode information
 */
export async function getStripeMode() {
    try {
        if (!STRIPE_SECRET_KEY) {
            await initStripeConfig();
        }

        return {
            success: true,
            mode: STRIPE_MODE,
            isTestMode: STRIPE_MODE === 'test',
            isLiveMode: STRIPE_MODE === 'live'
        };
    } catch (error) {
        console.error('‚ùå Error getting Stripe mode:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

